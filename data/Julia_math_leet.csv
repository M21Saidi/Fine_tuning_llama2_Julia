solution
"function path_sum_113(node::Union{Nothing,TreeNode}, target::Int)::Vector{Vector{Int}}
    isnothing(node) && return Vector{Vector{Int}}[]
    isnothing(node.left) &&
        isnothing(node.right) &&
        return node.val != target ? Vector{Vector{Int}}[] : [[target]]
    paths = path_sum_113(node.left, target - node.val)
    paths = vcat(paths, path_sum_113(node.right, target - node.val))
    for path in paths
        pushfirst!(path, node.val)
    end
    return paths
end"
"function find_radius(houses::Vector{Int}, heaters::Vector{Int})::Int
    sort!(heaters)
    heaters = [-Inf; heaters; Inf]
    res = 0
    for house in houses
        loc = searchsortedfirst(heaters, house)
        res = max(res, min(house - heaters[loc - 1], heaters[loc] - house))
    end

    return convert(Int, res)
end"
"function max_distance(position::Vector{Int}, m::Int)
    sort!(position)
    lowest, highest = 1, position[end] - position[1] 
    while lowest < highest
        mid = (highest + lowest + 1) ÷ 2
        left_pos = position[1]
        left_num = m - 1
        for pos in position
            if pos - left_pos >= mid 
                left_pos = pos
                left_num -= 1
                if left_num == 0
                    break
                end
            end
        end
        if left_num == 0
            lowest = mid 
        else
            highest = mid - 1
        end
    end
    lowest
end"
"function regions_by_slashes(grid::Vector{String})
    ## Like Problem 200
    function dfs(grid::Matrix{Int}, r, c)
        grid[r, c] = 1
        (r + 1 <= len * 3) && grid[r+1, c] == 0 && dfs(grid, r+1, c)
        (r - 1 > 0) && grid[r-1, c] == 0 && dfs(grid, r-1, c)
        (c + 1 <= len * 3) && grid[r, c+1] == 0 && dfs(grid, r, c+1)
        (c - 1 > 0) && grid[r, c-1] == 0 && dfs(grid, r, c-1)        
        nothing
    end
    len = length(grid)
    new_grid = fill(0, len * 3, len * 3)
    res = 0
    for i in 1:len
        for j in 1:len
            if grid[i][j] == '\\'
                new_grid[3 * i - 2, 3 * j - 2] = new_grid[3 * i - 1, 3 * j - 1] = new_grid[3 * i, 3 * j] = 1
            elseif grid[i][j] == '/'
                new_grid[3 * i - 2, 3 * j] = new_grid[3 * i - 1, 3 * j - 1] = new_grid[3 * i, 3 * j - 2] = 1
            end
        end
    end
    for r in 1 : len * 3
        for c in 1 : len * 3
            if new_grid[r, c] == 0
                res += 1
                dfs(new_grid, r, c)
            end
        end
    end
    res
end"
"function count_battleships(board::Matrix{Char})
    res = 0
    for I in CartesianIndices(board)
        board[I] == '.' && continue
        i, j = I.I
        (i == 1 || board[i - 1, j] == '.') &&
            (j == 1 || board[i, j - 1] == '.') &&
            (res += 1)
    end
    return res
end"
"function change(amount::Int, coins::Vector{Int})::Int
    dp = fill(0, amount)

    for coin in coins, x in coin:amount
        dp[x] += (x == coin) ? 1 : dp[x - coin]
    end

    return dp[amount]
end"
"function occurrences_after_bigram(text::String, first::String, second::String)
    words = split(text)
    res = String[]
    for i in 1:length(words)-2
        if words[i] == first && words[i+1] == second
            push!(res, words[i+2])
        end
    end
    return res
end"
"function can_jump(nums::Vector{Int})::Bool
    n, rightmost = length(nums), 1
    for (i, num) in enumerate(nums)
        i > rightmost && return false
        rightmost = max(rightmost, i + num)
        rightmost >= n && return true
    end
    false
end"
"function min_height_shelves(books::Vector{Vector{Int}}, shelf_width::Int)
    n = length(books)
    dp = OffsetArray(fill(typemax(Int) >> 1, n + 1), -1)    
    dp[0] = 0
    for i in 1:n
        idx, width, height = i - 1, books[i][1], books[i][2]
        while width <= shelf_width
            dp[i] = min(dp[i], dp[idx] + height)
            idx == 0 && break
            height = max(height, books[idx][2])
            width += books[idx][1]
            idx -= 1
        end
    end
    dp[end]
end"
"function matrix_score(A::Vector{Vector{Int}})::Int
    for vec in A     
        vec .⊻= 0 ⊻ vec[1]  ## the first column are all converted to 1
    end
    w, h, res = length(A[1]), length(A), 0
    ## res = h << (w - 1)
    for i in 1:w
        temp_cnt = 0
        for j in 1:h
            temp_cnt += A[j][i]
        end
        res += max(temp_cnt, h - temp_cnt) << (w - i)
    end
    return res
end"
"function num_special_equiv_groups(A::Vector{String})
    st = Set{Vector{Int}}()
    res = 0
    for s in A
        cnt = fill(0, 26 * 2)
        for i in 1:length(s)
            cnt[s[i] - 'a' + 1 + (i % 2)] += 1
        end
        !(cnt in st) && push!(st, cnt)
    end
    length(st)
end"
"function number_of_boomerangs(points::Vector{Vector{Int}})::Int
    res = 0
    for p in points
        distance_frequency = DefaultDict(0)
        for q in points
            p == q && continue
            dis = (p[1] - q[1])^2 + (p[2] - q[2])^2
            distance_frequency[dis] += 1
        end

        for k in values(distance_frequency)
            k > 1 && (res += k * (k - 1))
        end
    end

    return res
end"
"function lucky_numbers(mat::Matrix{Int})::Vector{Int}
    amax = argmin(mat; dims=1)
    amin = argmax(mat; dims=2)
    return mat[intersect(amax, amin)]
end"
can_make_arith(arr::Vector{Int})::Bool = length(unique!(diff(sort(arr)))) == 1
"function reordered_power_of2(n::Integer)
    cntr1 = OffsetArray(fill(0, 10), -1)
    cntr2 = OffsetArray(fill(0, 10), -1)
    function count_num!(cntr, n::Integer)
        fill!(cntr, 0)
        for d in digits(n)
            cntr[d] += 1            
        end
        cntr
    end
    count_num!(cntr1, n)
    for i in 0:31
        (cntr1 == count_num!(cntr2, 1 << i)) && return true
    end
    return false
end"
"function ladder_length(begin_word::String, end_word::String, word_list::Vector{String})::Int
    function isadj(s1, s2)
        flg = false
        for i in 1:length(s1)
            if s1[i] != s2[i]
                if flg
                    return false
                else
                    flg = true
                end
            end
        end
        return true
    end
    if !(end_word in word_list)
        return 0
    end
    !(begin_word in word_list) && push!(word_list, begin_word)
    s, t = findall(x -> x == begin_word, word_list)[1],
    findall(x -> x == end_word, word_list)[1]
    ## println(s, "", "", t)
    ### wl = collect.(word_list)
    len = length(word_list)
    edges = [Set{Int}() for i in 1:len]
    ### construct adj list
    for i in 1:len
        for j in (i + 1):len
            if isadj(word_list[i], word_list[j])
                push!(edges[i], j)
                push!(edges[j], i)
            end
        end
    end
    ## BFS
    qs, qt = Queue{Int}(), Queue{Int}()
    dists = [0 for i in 1:len]
    visited = [0 for i in 1:len]
    enqueue!(qs, s)
    enqueue!(qt, t)
    visited[s] = 1
    visited[t] = 2
    dists[s] = dists[t] = 1
    while !isempty(qs) && !isempty(qt)
        rt1, rt2 = dequeue!(qs), dequeue!(qt)
        dis1, dis2 = dists[rt1] + 1, dists[rt2] + 1
        ## println(rt1, "" "", dis1)
        for neib in edges[rt1]
            if visited[neib] == 2
                return dis1 + dists[neib] - 1
            elseif visited[neib] == 0
                visited[neib] = 1
                enqueue!(qs, neib)
                dists[neib] = dis1
            end
        end
        for neib in edges[rt2]
            if visited[neib] == 1
                return dis2 + dists[neib] - 1
            elseif visited[neib] == 0
                visited[neib] = 2
                enqueue!(qt, neib)
                dists[neib] = dis2
            end
        end
    end
end"
"## Automation
function is_number_65(s::String)::Bool
    ## initialize state
    state = ""start""
    ## recognize input state
    function switch(c::Char)::Int
        isdigit(c) && return 1
        c == '.' && return 2
        c in ""eE"" && return 3
        c in ""+-"" && return 4
        return 5
    end
    state_shift = Dict{String,Vector{String}}(
        ""start"" => [""num"", ""dot_part"", ""error"", ""sign"", ""error""],
        ""num"" => [""num"", ""dot_num"", ""e_part"", ""error"", ""error""],
        ""dot_num"" => [""dot_num"", ""error"", ""e_part"", ""error"", ""error""],
        ""e_num"" => [""e_num"", ""error"", ""error"", ""error"", ""error""],
        ""sign"" => [""num"", ""dot_part"", ""error"", ""error"", ""error""],
        ""dot_part"" => [""dot_num"", ""error"", ""error"", ""error"", ""error""],
        ""e_part"" => [""e_num"", ""error"", ""error"", ""e_sign"", ""error""],
        ""e_sign"" => [""e_num"", ""error"", ""error"", ""error"", ""error""],
    )
    for c in s
        state = state_shift[state][switch(c)]
        state == ""error"" && return false
    end
    return state in [""num"", ""dot_num"", ""e_num""]
end"
"function is_valid_parentheses(s::String)::Bool
    unclose, left_side = Char[], Dict{Char,Char}(')' => '(', ']' => '[', '}' => '{')
    for i in s
        if i in ""([{""
            push!(unclose, i)
        else
            (isempty(unclose) || left_side[i] != unclose[end]) && return false
            pop!(unclose)
        end
    end
    return isempty(unclose)
end"
"function find_target_inorder_traversal(root::TreeNode, k::Int)::Bool
    stack, nums = TreeNode{Int}[], Real[-Inf32] ## lowest bound
    while !isempty(stack) || !isnothing(root)
        while !isnothing(root)
            push!(stack, root)
            root = root.left
        end
        root = pop!(stack)
        while nums[end] + root.val > k
            pop!(nums)
        end
        root.val + nums[end] == k && return true
        push!(nums, root.val)
        root = root.right
    end
    return false
end"
"function first_bad_version(n::Int, is_bad_version::Function)::Int
    left, right = 1, n
    while left <= right
        mid = (left + right) >> 1
        if is_bad_version(mid)
            right = mid - 1
        else
            left = mid + 1
        end
    end
    return left
end"
"function get_bit_mask(word::String)::Int
    mask = 0

    for c in word
        i = Int(c) - Int('a')
        mask |= 1 << i
    end

    return mask
end

function find_num_of_valid_words(
    words::Vector{String},
    puzzles::Vector{String},
)::Vector{Int}
    letter_frequencies = Dict{Int,Int}()

    for word in words
        mask = get_bit_mask(word)
        letter_frequencies[mask] = get(letter_frequencies, mask, 0) + 1
    end

    solution = fill(0, length(puzzles))

    for (i, puzzle) in enumerate(puzzles)
        mask = get_bit_mask(puzzle)
        sub_mask = mask
        first_bit_index = Int(puzzle[1]) - Int('a')

        while true
            if (sub_mask >> first_bit_index & 1) == 1
                solution[i] += get(letter_frequencies, sub_mask, 0)
            end
            (sub_mask == 0) && break

            sub_mask = (sub_mask - 1) & mask
        end
    end

    return solution
end"
"function add_two_numbers(l1::ListNode, l2::ListNode)::ListNode
    carry = 0
    fake_head = cur = ListNode()

    while !isnothing(l1) || !isnothing(l2) || !iszero(carry)
        v1, v2 = 0, 0

        if !isnothing(l1)
            v1 = val(l1)
            l1 = next(l1)
        end

        if !isnothing(l2)
            v2 = val(l2)
            l2 = next(l2)
        end

        carry, v = divrem(v1 + v2 + carry, 10)
        next!(cur, ListNode(v))
        cur = next(cur)
        val!(cur, v)
    end
    return next(fake_head)
end"
"function fair_candy_swap(A::Vector{Int}, B::Vector{Int})
    set_a, set_b = Set(A), Set(B)
    dif = (sum(A) - sum(B)) ÷ 2
    for num_a in set_a
        ((num_a - dif) in set_b) && return [num_a, num_a - dif]
    end
end"
"reverse_words_557(s::String) = join([reverse(i) for i in split(s)], "" "")"
"function find_longest_chain(intervals::Vector{Tuple{Int,Int}})
    isempty(intervals) && return 0
    sort!(intervals; by=x -> x[2])
    lst, res = intervals[1][2], 1
    for intv in intervals
        intv[1] <= lst && continue
        res += 1
        lst = intv[2]
    end
    return res
end"
"function longest_ones(A::Vector{Int}, K::Int)
    l = r = 1
    len = length(A)
    cnt = res = 0
    while r <= len
        (A[r] == 0) && (cnt += 1)
        r += 1
        while cnt > K
            (A[l] == 0) && (cnt -= 1)
            l += 1
        end
        res = max(res, r - l)
    end
    return res
end"
"function common_chars(A::Vector{String})
    cnt = counter(A[1])
    for i in 2:length(A)
        tmp_cnt = counter(A[i])
        for k in union(keys(tmp_cnt), keys(cnt))
            cnt[k] = min(cnt[k], tmp_cnt[k]) 
        end
    end
    vcat([fill(k, v) for (k, v) in cnt if v > 0]...)
end"
"function max_num_of_ballons(text::String)::Int
    words = Dict{Char,Int}(s => 0 for s in ""balon"")
    for s in text
        if haskey(words, s)
            words[s] += 1
        end
    end
    return min(words['b'], words['a'], words['l'] ÷ 2, words['o'] ÷ 2, words['n'])
end"
"function smallest_rangeII(nums::Vector{Int}, k::Integer)
    sort!(nums)
    res = nums[end] - nums[1]
    for i in 2:length(nums)
        res = min(res, max(nums[end] - k, nums[i - 1] + k) - min(nums[1] + k, nums[i] - k))
    end    
    return res
end"
"function max_points(points::Vector{Vector{Int}})
    res = 0
    for i in 1:length(points)
        if res > length(points) - i 
            return res
        end
        cnt = DefaultDict{Rational, Int}(1)
        for j in i+1:length(points)
            cnt[(points[i][2] - points[j][2]) // (points[i][1] - points[j][1])] += 1
        end
        res = max(res, maximum(p.second for p in cnt))
    end    
    res
end"
"function is_same_tree(p::Union{TreeNode, Nothing}, q::Union{TreeNode, Nothing})::Bool
    if isnothing(p) && isnothing(q)
        return true
    elseif isnothing(p) || isnothing(q)
        return false
    elseif p.val != q.val
        return false
    else
        return is_same_tree(p.left, p.left) && is_same_tree(p.right, p.right)
    end
end"
"function length_of_longest_substring(s::String)::Int
    max_string, max_len = """", 0
    for c in s
        ## if c occurs twice in max_string
        if c in max_string
            max_string = max_string[(findfirst(c, max_string) + 1):end] * c
        else
            max_string *= c
            max_len = max(length(max_string), max_len)
        end
    end
    return max_len
end"
last_remaining(n::Int)::Int = n == 1 ? 1 : 2 * (n ÷ 2 + 1 - last_remaining(n ÷ 2))
"function orderly_queue(S::String, K::Int)
    if K == 1
        res = S
        for i in 2:length(S)
            res = min(res, S[i:end] * S[1:i-1])
        end
        return res
    end
    c_units = codeunits(S)[:]
    return c_units |> sort! |> String
end"
"function check_valid_string(s::String)
    lo, hi = 0, 0
    for ch in s
        if ch == '('
            lo += 1
            hi += 1
        elseif ch == ')'
            (lo > 0) && (lo -= 1)
            hi -= 1
        else
            (lo > 0) && (lo -= 1)
            hi += 1
        end
        if hi < 0
            return false
        end
    end
    return lo == 0
end"
"function to_lower_case(s::String)::String
    return lowercase(s)
end"
"function transpose_matrix(matrix::Vector{Vector{Int}})::Vector{Vector{Int}}
    m, n = length(matrix), length(matrix[1])

    transpose_mat = [[0 for _ = 1:m] for _ = 1:n]

    for i = 1:m, j = 1:n
        transpose_mat[j][i] = matrix[i][j]
    end

    return transpose_mat
end"
"function construct_from_pre_post(pre::Vector{Int}, post::Vector{Int})
    if isempty(pre)
        return nothing
    end
    root = TreeNode(pre[1])
    if length(pre) == 1
        return root
    end
    idx = findfirst(==(pre[2]), post)
    root.left = construct_from_pre_post(pre[2:1+idx], post[1:idx])
    root.right = construct_from_pre_post(pre[2+idx:end], post[1+idx:end-1])
    root
end"
"length_of_last_word(s::String) = length(rsplit(s, ' '; limit = 2, keepempty=false)[end])"
"struct MountainArray
    vec::Vector{Int}
end

Base.length(ma::MountainArray) = length(ma.vec)
Base.getindex(ma::MountainArray, i) = ma.vec[i]

function find_in_mountain_array(ma::MountainArray, target::Int)
    len = length(ma)
    i, j = 1, len
    while i != j
        mid = (i + j) >> 1
        ma[mid] > ma[mid + 1] ? (j = mid) : (i = mid + 1)
    end
    idx1 = searchsortedfirst(1:i, i; by=i -> ma[i] >= target)
    ma[idx1] == target && return idx1
    idx2 = searchsortedfirst((i + 1):len, i; by=i -> ma[i] <= target) + i
    ma[idx2] == target && return idx2
    return -1
end"
"function max_sum_submatrix(matrix::AbstractMatrix{Int}, k::Int)
    m, n = size(matrix)
    m > n && return max_sum_submatrix(matrix', k)
    pref_sum = OffsetArray(fill(0, m + 1, n + 1), -1, -1)

    for i in 1:m, j in 1:n
        pref_sum[i, j] = pref_sum[i - 1, j] + pref_sum[i, j - 1] + matrix[i, j] -
                         pref_sum[i - 1, j - 1]
    end
    res = typemin(Int)
    for tp in 1:m, bot in tp:m
        ss = SortedSet{Int}()
        push!(ss, 0)
        for r in 1:n
            rows_sum = pref_sum[bot, r] - pref_sum[tp - 1, r]
            tk = searchsortedfirst(ss, rows_sum - k)
            tk != pastendsemitoken(ss) && (res = max(res, rows_sum - deref((ss, tk))))
            push!(ss, rows_sum)
        end
    end
    return res
end"
"struct NumMatrix
    sums::Vector{Vector{Int}}
    function NumMatrix(matrix::Vector{Vector{Int}})
        m, n = length(matrix), length(matrix[1])
        sums = [fill(0, n + 1) for _ = 1:m]

        for i = 1:m, j = 1:n
            sums[i][j+1] = sums[i][j] + matrix[i][j]
        end

        new(sums)
    end
end

sum_region(matrix::NumMatrix, row1::Int, col1::Int, row2::Int, col2::Int) =
    sum(matrix.sums[i][col2+1] - matrix.sums[i][col1] for i = row1:row2)"
"function flood_fill!(image::Matrix{Int}, sr::Int, sc::Int, new_color::Int)::Matrix{Int}
    ind = CartesianIndex((sr + 1, sc + 1)) ## index correction
    old_color, image[ind] = image[ind], new_color
    old_color == new_color && return image
    inds, queue = CartesianIndices(image), [ind]
    while !isempty(queue)
        ind = popfirst!(queue)
        for I in [(-1, 0), (1, 0), (0, -1), (0, 1)]
            new_I = ind + CartesianIndex(I)
            if new_I ∈ inds && image[new_I] == old_color
                image[new_I] = new_color
                push!(queue, new_I)
            end
        end
    end
    return image
end"
"function find_kpairs(nums::Vector{Int}, k::Int)
    cntr = counter(nums)
    res = 0
    if k > 0
        for (ky, vl) in cntr
            res += (ky - k in keys(cntr)) ? 1 : 0
        end
    else
        for (ky, vl) in cntr
            res += ifelse(vl > 1, 1, 0)
        end
    end
    return res
end"
"function four_sum_count(A::Vector{Int}, B::Vector{Int}, C::Vector{Int}, D::Vector{Int})::Int
    dic = counter([a + b for a in A for b in B])
    return sum(get(dic, -c - d, 0) for c in C for d in D)
end"
"function delete_duplicates!(head::Union{ListNode,Nothing})::Union{ListNode,Nothing}
    cur = head
    while !isnothing(cur)
        node, value = next(cur), val(cur)
        while !isnothing(node) && val(node) == value
            cur.next = node = next(node)
        end
        cur = next(cur)
    end
    return head
end"
"function int_to_roman(num::Int)::String
    table = (""IVX"", ""XLC"", ""CDM"", ""M--"")
    function get_num(n::Int, st::String)::String
        I, V, X = st
        0 <= n <= 3 && return I^n
        n == 4 && return I * V
        5 <= n <= 8 && return V * I^(n - 5)
        return I * X
    end
    return join(reverse!([get_num(n, table[i]) for (i, n) in enumerate(digits(num))]))
end"
"using DataStructures

function group_anagrams(strs::Vector{String})::Vector{Vector{String}}
    swords = DefaultDict{AbstractString,Vector{String}}(Vector{Int})
    for word in strs
        key = join(sort(collect(word)))
        push!(swords[key], word)
    end
    res = Vector{Vector{String}}()
    for (k, v) in swords
        push!(res, v)
    end
    return res
end"
"function min_operations(nums::Vector{Int}, x::Int)
    target = sum(nums) - x
    target < 0 && return -1
    println(target)
    left, right, maxn = 0, 0, -1
    len = length(nums)
    while right < len
        target -= nums[right += 1]
        while target < 0
            target += nums[left += 1]
        end
        (target == 0) && (maxn = max(maxn, right - left))
    end
    maxn == -1 ? maxn : len - maxn
end"
"function max_chunks_to_sorted(arr::Vector{Int})::Int
    ##count = DefaultDict(1)
    ##non_zeros, res = 0, 0
    res = s1 = s2 = 0
    for (a, b) in zip(arr, sort(arr))
        s1 += a
        s2 += b
        (s1 == s2) && (res += 1)
        ## count[a] += 1
        ## if count[a] == 0
        ##     non_zeros -= 1
        ## elseif count[a] == 1
        ##     non_zeros += 1
        ## end
        ## count[b] -= 1
        ## if count[b] == 0
        ##     non_zeros -= 1
        ## elseif count[b] == -1
        ##     non_zeros += 1
        ## end
        ## (non_zeros == 0) && (res += 1)
    end

    return res
end"
"function max_visible_points(points::Vector{Vector{Int}}, view_angle::Int,
                            location::Vector{Int})
    points .-= Ref(location)
    len = length(points)
    angles = [atand(point...) for point in points if point != [0, 0]]
    res, samen = 0, len - length(angles)
    sort!(angles)
    angles = vcat(angles, angles .+ 360)
    for i in 1:length(angles)÷2
        idx = searchsortedlast(@view(angles[i+1:end]), angles[i] + view_angle)  
        res = max(res, idx+1+samen)
    end
    res
end"
"function longest_arith_seq_length(nums::Vector{Int})
    len = length(nums)
    len == 1 && return 0
    dp = fill(0, len, 1001)
    res = 0
    for i in 1:len, j in 1:(i - 1)
        d = nums[i] - nums[j] + 501
        dp[i, d] = max(dp[i, d], dp[j, d] + 1)
        res = max(res, dp[i, d])
    end
    return res + 1
end"
"function find_min_arrow_shots(points::Vector{Vector{Int}})::Int
    if isempty(points)
        return 0
    end
    sort!(points; by=x -> x[2])
    ed, res = points[1][2], 1
    for point in points
        if point[1] > ed
            res += 1
            ed = point[2]
        end
    end
    return res
end"
"## using double pointers
function two_sum_167(numbers::Vector{Int}, target::Int)::Vector{Int}
    left, right = 1, length(numbers)
    while left < right
        num = numbers[left] + numbers[right]
        if num > target
            right -= 1
        elseif num < target
            left += 1
        else
            return [left, right]
        end
    end
    [-1, -1]
end"
"num_of_trees(n::Int) = binomial(2 * n, n) - binomial(2 * n, n + 1)"
"function lands_num(grid::Vector{Vector{String}})
    nr, nc = length(grid), length(grid[1])
    function dfs(grid::Vector{Vector{String}}, r, c)
        grid[r][c] = ""0""
        (r + 1 <= nr) && grid[r+1][c] == ""1"" && dfs(grid, r+1, c)
        (r - 1 > 0) && grid[r-1][c] == ""1"" && dfs(grid, r-1, c)
        (c + 1 <= nc) && grid[r][c+1] == ""1"" && dfs(grid, r, c+1)
        (c - 1 > 0) && grid[r][c-1] == ""1"" && dfs(grid, r, c-1)        
        nothing
    end
    res = 0
    for i in 1:nr
        for j in 1:nc
            if grid[i][j] == ""1""
                res += 1
                dfs(grid, i, j)                
            end 
        end
    end    
    res
end"
"using DataStructures

Base.@kwdef struct MedianFinder
    maxheap::BinaryMaxHeap{Int} = BinaryMaxHeap{Int}()
    minheap::BinaryMinHeap{Int} = BinaryMinHeap{Int}()
end
## function Base.show(io::IO, heap::MedianFinder)
##     return print(io, ""$(heap.maxheap.valtree):max -- min:$(reverse(heap.minheap.valtree))"")
## end

function add_num!(heap::MedianFinder, num::Int)
    ## maximal element of maxheap <= minimal element of minheap
    ## length of maxheap <= length of minheap
    hi, ha = heap.minheap, heap.maxheap
    if length(ha) < length(hi)
        ## e.g. [2]--[4,5] =6> [2]--[4,5,6] => [2,4]--[5,6]
        push!(hi, num)
        push!(ha, pop!(hi))
    else
        ## e.g. [4]--[5] =2> [2,4]--[5] => [2]--[4,5]
        push!(ha, num)
        push!(hi, pop!(ha))
    end
    return nothing
end

function find_median(heap::MedianFinder)::Float64
    hi, ha = heap.minheap, heap.maxheap
    return length(hi) == length(ha) ? (first(hi) + first(ha)) / 2 : first(hi)
end"
"function roman_to_integer(s::AbstractString)
    table = Dict(
        'I'      =>       1,
        'V'      =>       5,
        'X'      =>       10,
        'L'      =>       50,
        'C'      =>       100,
        'D'      =>       500,
        'M'      =>       1000,
    )

    nums = [table[c] for c in s]

    for idx = 1:lastindex(nums)-1
        nums[idx] *= nums[idx] >= nums[idx+1] ? 1 : -1 
    end

    return sum(nums)
end

## add your code here:"
"function asteroid_collision(asteroids::Vector{Int})
    res = Int[]
    for ast in asteroids
        ast > 0 && (push!(res, ast); continue)
        flg = true
        while !isempty(res) && res[end] > 0
            cmp = res[end] + ast
            if cmp < 0
                pop!(res)
            elseif cmp == 0
                pop!(res)
                flg = false
            else
                flg = false
                break
            end
        end
        flg && push!(res, ast)
    end
    return res
end"
"function add_digits(num::Int)::Int
    num <= 9 && return num
    return iszero(num % 9) ? 9 : num % 9
end"
"function find_nth_digit(n::Int)
    ant = [0, 10, 190, 2890, 38890, 488890, 5888890, 68888890, 788888890]
    num_begin = [0, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000]
    idx = searchsortedlast(ant, n)
    num = (n - ant[idx]) ÷ idx + num_begin[idx]
    posi = (n - ant[idx]) % idx
    return num % (10^(idx - posi)) ÷ 10^(idx - posi - 1)
end"
"function next_permutation(nums::Vector{Int})
    next_perm!(nums)
    return nums
end"
"function is_ideal_permutation(A::Vector{Int})
    m = A[end]
    for i in length(A):-1:3
        m = min(m, A[i])
        if A[i - 2] > m
            return false
        end
    end
    return true
end"
"function triangle_number(nums::Vector{Int})
    res, len = 0, length(nums)
    sort!(nums)
    @inbounds for i in 1:len-2
        nums[i] == 0 && continue
        k = i + 2
        for j in i+1:len-1
            while k <= len && nums[i] + nums[j] > nums[k]; k += 1; end
            res += k - j - 1
        end
    end
    return res
end"
"reverse_list(head::Nothing) = head
function reverse_list(head::ListNode)::ListNode
    new_head = pre_node = nothing
    while !isnothing(head)
        new_head = ListNode(head.val)
        pre_node, new_head.next = new_head, pre_node
        head = head.next
    end
    return new_head
end"
"merge_trees(::Nothing, ::Nothing) = nothing
merge_trees(::Nothing, root2::TreeNode) = root2
merge_trees(root1::TreeNode, ::Nothing) = root1
function merge_trees(root1::TreeNode, root2::TreeNode)::TreeNode
    root = TreeNode(root1.val + root2.val)
    root.left = merge_trees(root1.left, root2.left)
    root.right = merge_trees(root1.right, root2.right)
    return root
end"
"function max_profit_iii(prices::Vector{Int})::Int
    sell1 = sell2 = 0
    buy2 = buy1 = -prices[1]
    for i in 2:length(prices)
        sell2 = max(buy2 + prices[i], sell2) 
        buy2 = max(sell1 - prices[i], buy2)
        sell1 = max(buy1 + prices[i], sell1)
        buy1 = max(buy1, -prices[i])
    end
    sell2
end"
"## Double Pointers
function remove_nth_from_end_by_double_pointers!(
    head::ListNode, n::Int
)::Union{Nothing,ListNode}
    p1 = p2 = head
    for _ in 1:n
        p2 = next(p2)
    end
    ## remove the first node
    isnothing(p2) && return next(head)
    p2 = p2.next ## let distance(p1, p2) = n + 1
    while !isnothing(p2)
        p1, p2 = next(p1), next(p2)
    end
    p1.next = p1.next.next ## remove one node
    return head
end"
"mutable struct OrderStream
    data::AbstractVector{T} where {T<:AbstractString}
    n::Int
    ptr::Int
    ## initialize
    OrderStream(n::Int) = new(fill("""", n), n, 1)
end

function insertdata!(stream::OrderStream, idkey::Int, val::String)
    stream.data[idkey] = val
    res = String[]
    isempty(stream.data[stream.ptr]) && return res
    for i in (stream.ptr):(stream.n)
        if isempty(stream.data[i])
            stream.ptr = i
            return res
        else
            push!(res, stream.data[i])
        end
    end
    return res
end"
"function UFS()
    function findRoot(u::Int, farther::Vector{Int})
        return (u == farther[u]) ? (u) : (farther[u] = findRoot(farther[u], farther))        
    end
    
    function merge(u::Int, v::Int, farther::Vector{Int})
        u = findRoot(u, farther)
        v = findRoot(v, farther)
        (u == v) || (farther[u] = v)
        nothing
    end

    function issameRoot(u::Int, v::Int, farther::Vector{Int})
        return findRoot(u, farther) == findRoot(v, farther) 
    end

    findRoot, merge, issameRoot
end

function findRedundantConnection(edges::Vector{Vector{Int}})::Vector{Int}
    farther = collect(1:1000)
    findRoot, merge, issameRoot = UFS()
    for edge in edges
        if issameRoot(edge..., farther)
            return edge
        end
        merge(edge..., farther)
    end
end"
"function diameter_of_binary_tree(root::TreeNode)::Int
    return max(
        diameter_of_binary_tree(root.left),
        diameter_of_binary_tree(root.right),
        _max_depth_to_leaf(root.left) + _max_depth_to_leaf(root.right) + 1,
    ) - 1
end

diameter_of_binary_tree(root::Nothing) = 0

function _max_depth_to_leaf(root::TreeNode)
    return max(1 + _max_depth_to_leaf(root.left), 1 + _max_depth_to_leaf(root.right))
end

_max_depth_to_leaf(::Nothing) = 0"
"function remove_kdigits(num::String, k::Int)::String
    num_code = codeunits(num)
    stk = UInt8[]
    for ch in num_code
        if k == 0 || isempty(stk)
            push!(stk, ch)
        else
            while !isempty(stk) && stk[end] > ch && k > 0
                pop!(stk)
                k -= 1
            end
            push!(stk, ch)
        end
    end
    idx = findfirst(x -> x != UInt8('0'), stk)
    if idx === nothing
        return ""0""
    end
    return String(@view stk[idx:(end - k)])
end"
"function two_city_sched_cost(costs::Vector{Vector{Int}})::Int    
    sort!(costs; by = x -> x[1] - x[2])
    n = length(costs) ÷ 2
    res = 0
    for i in 1:n
        res += costs[i][1] + costs[i + n][2]
    end
    res
end"
"function spiral_order(matrix::Vector{Vector{Int}})::Vector{Int}
    res = Int[]
    while !isempty(matrix)
        for each in popfirst!(matrix)
            push!(res, each)
        end

        if !isempty(matrix) && !isempty(matrix[1])
            for row in matrix
                push!(res, pop!(row))
            end
        end

        if !isempty(matrix)
            for each in pop!(matrix)[end:-1:1]
                push!(res, each)
            end
        end

        if !isempty(matrix) && !isempty(matrix[1])
            for row in matrix[end:-1:1]
                push!(res, popfirst!(row))
            end
        end
    end

    return res
end"
"function calculate_points(ops::Vector{String})::Int
    scores = Int[]
    for op in ops
        if op == ""+""
            push!(scores, last(scores) + scores[end - 1])
        elseif op == ""D""
            push!(scores, last(scores) * 2)
        elseif op == ""C""
            pop!(scores)
        else
            push!(scores, parse(Int, op))
        end
    end
    return sum(scores)
end"
"function max_area_of_island(grid::Matrix{Int})
    function dfs(grid::Matrix{Int}, I)
        grid[I] = 0
        res = 1
        idcs = CartesianIndices(grid)
        for neighb in ((1, 0), (0, 1), (-1, 0), (0, -1))
            new_I = I + CartesianIndex(neighb)
            (new_I ∈ idcs && grid[new_I] == 1) && (res += dfs(grid, new_I))
        end
        return res
    end
    res = 0
    for I in CartesianIndices(grid)
        (grid[I] == 1) && (res = max(res, dfs(grid, I)))
    end
    return res
end"
"function summary_ranges(nums::Vector{Int})::Vector{String}
    if length(nums) < 1
        return String[]
    end
    res = String[]
    bg = ed = nums[1]
    for i in 2:length(nums)
        if nums[i] - ed == 1
            ed += 1
        else
            (bg == ed) ? (push!(res, ""$(bg)"")) : (push!(res, ""$bg->$ed""))
            bg = ed = nums[i]
        end
    end
    (bg == ed) ? (push!(res, ""$(bg)"")) : (push!(res, ""$bg->$ed""))
    res
end"
"function last_substring(s::String)
    m_ch = maximum(s)
    mc_pos = findall(==(m_ch), s)
    pos, window_len, new_window_len = first(mc_pos), 1, 1
    for idx in 2:length(mc_pos)
        if mc_pos[idx] == mc_pos[idx - 1] + 1
            new_window_len += 1
        else
            if new_window_len > window_len
                window_len = new_window_len
                pos = mc_pos[idx - 1] - new_window_len + 1
            end
            new_window_len = 1
        end
    end
    if new_window_len > window_len
        window_len = new_window_len
        pos = mc_pos[end] - new_window_len + 1
    end
    return s[pos:end]
end"
"function rob_213(nums::Vector{Int})::Int
    length(nums) <= 3 && return max(nums...)
    ## start from house 1
    a, b1 = nums[1], nums[1] + nums[3]
    for num in @view nums[4:(end - 1)]
        a, b1 = b1, max(b1, a + num)
    end
    ## start from house 2
    a, b2 = nums[2], max(nums[2], nums[3])
    for num in @view nums[4:end]
        a, b2 = b2, max(b2, a + num)
    end
    return max(b1, b2)
end"
"function preimage_size_fzf(K::Int)
    zeta(x) = x > 0 ? x ÷ 5 + zeta(x ÷ 5) : 0
    lo, hi = K, 5 * K + 1
    while lo < hi
        mid = (lo + hi) ÷ 2
        z_mid = zeta(mid)
        if z_mid == K
            return 5
        elseif z_mid < K
            lo = mid + 1
        else
            hi = mid
        end
    end
    return 0
end"
"function exclusive_time(n::Int, logs::Vector{T}) where {T<:AbstractString}
    logs = [
        (parse(Int, id) + 1, state, parse(Int, time)) for
        (id, state, time) in split.(logs, ':')
    ]
    task, _, pretime = first(logs)
    times, tasks = zeros(Int, n), [task]
    for (id, state, curtime) in @views(logs[2:end])
        interval, pretime = curtime - pretime, curtime
        isempty(tasks) || (times[last(tasks)] += interval)
        if state == ""start"" ## new task started
            push!(tasks, id)
        else ## task ended
            times[pop!(tasks)] += 1 ## add end time
            pretime += 1
        end
    end
    return times
end"
"function find_shortest_sub_array(nums::Vector{Int})
    mp = Dict{Int,Vector{Int}}()

    for (idx, num) in enumerate(nums)
        if num in keys(mp)
            mp[num][1] += 1
            mp[num][3] = idx
        else
            mp[num] = [1, idx, idx]
        end
    end
    maxn = minlen = 0
    for (cnt, l, r) in values(mp)
        if maxn < cnt
            maxn = cnt
            minlen = r - l + 1
        elseif maxn == cnt
            minlen = min(minlen, r - l + 1)
        end
    end
    minlen
end"
"function reaching_points(sx, sy, tx, ty)
    while tx >= sx && ty >= sy
        if tx == ty
            break
        end
        if tx > ty
            if ty > sy 
                tx %= ty;
            else 
                return (tx - sx) % ty == 0;
            end
        else
            if tx > sx 
                ty %= tx;
            else 
                return (ty - sy) % tx == 0;
            end
        end
    end
    tx == sx && ty == sy
end"
"function is_one_bit_character(bits::Vector{Int})::Bool
    pos = findlast(x -> x == 0, @view bits[1:(end - 1)])
    pos === nothing && return length(bits) % 2 == 1
    return (length(bits) - pos) % 2 == 1
end"
"## BFS
function word_break_bfs(s::String, word_dict::Vector{String})::Bool
    n, word_dict = length(s), sort!(word_dict; by=x -> length(x))
    valids, valid_pos = fill(false, n), [0]
    while !isempty(valid_pos)
        pos = popfirst!(valid_pos)
        for word in word_dict
            (new_pos = pos + length(word)) > n && break
            new_pos == n && s[(pos + 1):new_pos] == word && return true
            if !valids[new_pos] && s[(pos + 1):new_pos] == word
                valids[new_pos] = true
                push!(valid_pos, new_pos)
            end
        end
    end
    return false
end

## Dynamic Programming
function word_break(s::String, word_dict::Vector{String})::Bool
    lens = sort!(unique!(length.(word_dict)))
    dp = append!([true], fill(false, length(s)))
    for i in eachindex(dp)
        for len in lens
            i > len || break
            dp[i - len] && s[(i - len):(i - 1)] ∈ word_dict && (dp[i] = true)
        end
    end
    return last(dp)
end"
"function partition_ps(s::String)
    len = length(s)
    is_ps = fill(true, len, len)
    for i in len:-1:1, j in (i + 1):len
        is_ps[i, j] = (s[i] == s[j]) && is_ps[i + 1, j - 1]
    end
    function dfs(start::Int)
        start == len && return [[SubString(s, len, len)]]
        res = Vector{String}[]
        for ed in start:len
            !is_ps[start, ed] && continue
            for it in dfs(ed + 1)
                push!(res, pushfirst!(it, SubString(s, start, ed)))
            end
        end
        return res
    end
    return dfs(1)
end"
"using DataStructures
function possible_bipartition(n::Int, dislikes::Vector{Vector{Int}})
    int_ds = IntDisjointSets(n)
    graph = [Int[] for _ in 1:n]
    for (a, b) in dislikes
        push!(graph[a], b)
        push!(graph[b], a)
    end
    for i in 1:n
        for j in graph[i]
            union!(int_ds, graph[i][1], j)
            DataStructures.in_same_set(int_ds, i, j) && return false
        end
    end
    return true
end"
"function is_toeplitz_matrix(matrix::Vector{Vector{Int}})
    m, n = length(matrix), length(matrix[1])

    for i in 1:(m - 1)
        (matrix[i][1:(end - 1)] != matrix[i + 1][2:end]) && return false
    end

    return true
end"
"function find_unsorted_subarray(nums::Vector{Int})
    stk = Int[]
    l, r = length(nums) + 1, 1
    for i in eachindex(nums)
        while !isempty(stk) && nums[stk[end]] > nums[i]
            l = min(l, pop!(stk))
        end
        push!(stk, i)
    end
    empty!(stk)
    for i in length(nums):-1:1
        while !isempty(stk) && nums[stk[end]] < nums[i]
            r = max(r, pop!(stk))
        end
        push!(stk, i)
    end
    return r - l > 0 ? r - l + 1 : 0
end"
"function all_cells_dist_order(rows::Int, cols::Int, rcenter::Int, ccenter::Int)
    rs = max(rcenter - 1, rows - rcenter)
    cs = max(ccenter - 1, cols - ccenter)
    iters = rs + cs
    res = Vector{Tuple{Int,Int}}(undef, rows * cols)
    res[1] = (rcenter, ccenter)
    idx = 2
    cidx = CartesianIndex(1, 1):CartesianIndex(rows, cols)
    for i in 1:iters
        for j in (-i):i
            for k in (i - abs(j), abs(j) - i)
                cur_idx = CartesianIndex(rcenter + j, ccenter + k)
                if cur_idx in cidx
                    res[idx] = cur_idx.I
                    idx += 1
                end
                k == 0 && break
            end
        end
    end
    return res
end"
"## BFS algorithm
function num_of_enclaves_bfs(grid::Vector{Vector{Int}})::Int
    m, n, queue = length(grid), length(grid[1]), Tuple{Int,Int}[]
    (m <= 2 || n <= 2) && return 0
    for i in 1:m ## left and right border
        grid[i][1] == 1 && push!(queue, (i, 1))
        grid[i][n] == 1 && push!(queue, (i, n))
    end
    for i in 2:(n - 1)
        grid[1][i] == 1 && push!(queue, (1, i))
        grid[m][i] == 1 && push!(queue, (m, i))
    end
    walkoff = copy(queue)
    while length(queue) != 0
        i, j = popfirst!(queue)
        for (a, b) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]
            if a >= 1 &&
                b >= 1 &&
                a <= m &&
                b <= n &&
                grid[a][b] != 0 &&
                !((a, b) in walkoff)
                push!(walkoff, (a, b))
                push!(queue, (a, b))
            end
        end
    end
    return sum(sum(line) for line in grid) - length(walkoff)
end"
"function first_missing_positive(nums::Vector{Int})
    len = length(nums)
    for idx in 1:len
        while nums[idx] <= len && nums[idx] > 0 && nums[nums[idx]] != nums[idx]
            num = nums[idx]
            nums[idx], nums[num] = nums[num], nums[idx]
        end
    end
    for i in 1:len
        (nums[i] != i) && return i
    end
end"
"function circular_array_loop(nums::Vector{Int})
    len = length(nums)
    for i in 1:length(nums)
        if nums[i] == -2000 || nums[i] == 2000 
            continue
        end
        j = mod1(i + nums[i], len)
        lst = i
        nums[i] = 2000 * sign(nums[i])
        while true
            if nums[i] * nums[j] < 0 || j == lst
                break
            elseif abs(nums[j]) == 2000 && j ≥ i
                return true 
            end
            nums[j], j, lst = 2000 * sign(nums[j]), mod1(nums[j] + j, len), j
        end
    end
    return false
end"
"function my_atoi(s::String)::Int
    s = lstrip(s)
    if length(s) == 0
        0
    else
        try
            m = match(r""^[\-\+]?[0-9]+"", s)
            if isnothing(m)
                0
            else
                parse(Int32, m.match)
            end
        catch
            if s[1] == '-'
                typemin(Int32)
            else
                typemax(Int32)
            end
        end
    end
end"
"function gray_code(N::Int)
    powN = 1 << N
    res = Array{Int}(undef, powN)
    for i in 0:powN-1
        res[i + 1] = i ⊻ (i >> 1);
    end
    res
end"
"function integer_break(n::Int)
    n <= 3 && return n - 1
    a, b = n ÷ 3, n % 3
    b == 0 && return 3 ^ a
    b == 1 && return 3 ^ (a - 1) * 4
    return 3 ^ a * 2
end"
"function rotate_48(matrix::Matrix{Int})
    n = size(matrix, 1)
    for i in 1:div(n, 2), j in i:(n - i)
        matrix[i, j], matrix[j, n + 1 - i], matrix[n + 1 - i, n + 1 - j], matrix[n + 1 - j, i] = matrix[
            n + 1 - j, i
        ],
        matrix[i, j], matrix[j, n + 1 - i],
        matrix[n + 1 - i, n + 1 - j]
    end
    return matrix
end"
"function subarray_bitwise_ors(A::Vector{Int})
    res = Set{Int}()
    cur = Set{Int}()
    for num in A
        cur2 = Set{Int}()
        for n in cur
            push!(cur2, n | num)
        end
        push!(cur2, num)
        cur = cur2
        union!(res, cur)
    end
    return length(res)
end"
"function largest_vals_from_labels(
    vals::Vector{Int}, labels::Vector{Int}, num_wanted::Int, use_limit::Int
)
    dc = Dict{Int,Vector{Int}}()
    for (idx, label) in enumerate(labels)
        v = get!(dc, label, Int[])
        push!(v, vals[idx])
    end
    res = Int[]
    for v in values(dc)
        sort!(v; rev=true)
        append!(res, @view(v[1:min(use_limit, end)]))
    end
    sort!(res; rev=true)
    return sum(res[1:min(num_wanted, end)])
end"
"function is_n_straight_hand(hand::Vector{Int}, group_size::Integer)::Bool
    length(hand) % group_size == 0 || return false
    cntr = counter(hand)    
    while !isempty(cntr)
        k = minimum(keys(cntr))
        v = cntr[k]
        for i in (0:group_size-1) .+ k
            cntr[i] -= v
            cntr[i] < 0 && return false
            cntr[i] == 0 && pop!(cntr.map, i)
        end
    end
    return true
end"
"function repeated_n_times(A::Vector{Int})
    for i in 2:length(A) 
        if A[i] == A[i - 1]
            return A[i]
        end
    end
    
    ## 3X3X OR 3XX3 OR X3X3
    return (A[1] == A[3] || A[1] == A[4]) ? A[1] : A[2]
end"
"function compute_area(coord::Vector{Int})
    if coord[1] > coord[5]
        coord[1:4], coord[5:8] = coord[5:8], coord[1:4]
    end
    if coord[8] <= coord[2] || coord[6] >= coord[4] || coord[5] >= coord[3]
        return 0
    end
    return (coord[3] - coord[1]) * (coord[4] - coord[2]) + 
            (coord[7] - coord[5]) * (coord[8] - coord[6]) -
            (min(coord[3], coord[7]) - coord[5]) * (min(coord[8], coord[4]) - max(coord[2], coord[6]))
end"
"function array_pair_sum(nums::Vector{Int})
    sort!(nums)
    sum(nums[1:2:end])
end"
"## double pointers
function middle_node_by_double_pointers(head::ListNode)::ListNode
    p1 = p2 = head
    while !isnothing(p2)
        p2 = next(p2)
        isnothing(p2) && return p1
        p2, p1 = p2.next, p1.next
    end
    return p1
end"
"## method 1: using merge sort
function count_smaller_method1(arr::Vector{Int})::Vector{Int}
    res = fill(0, length(arr))
    function merge_sort(arr::AbstractVector)::AbstractVector
        ## arr = [(idx1, num1), ...]
        (n = length(arr)) == 1 && return arr
        mid = n >> 1
        lpart = merge_sort(@view(arr[1:mid]))
        rpart = merge_sort(@view(arr[(mid + 1):end]))
        return merge_sorted(lpart, rpart)
    end
    function merge_sorted(
        lpart::AbstractVector, rpart::AbstractVector
    )::Vector{Tuple{Int,Int}}
        l1, l2 = length(lpart), length(rpart)
        combined = Vector{Tuple{Int,Int}}(undef, l1 + l2)
        p1 = p2 = 1
        for pos in eachindex(combined)
            if p2 > l2 || p1 <= l1 && lpart[p1][2] <= rpart[p2][2]
                combined[pos] = lpart[p1]
                res[lpart[p1][1]] += (p2 - 1)
                p1 += 1
            else
                combined[pos] = rpart[p2]
                p2 += 1
            end
        end
        return combined
    end

    merge_sort(collect(enumerate(arr)))
    return res
end

## method 2: using binary search
## require function ""search_left_border"" from solution 33
function count_smaller_method2(arr::Vector{Int})::Vector{Int}
    queue, res = Int[], Array{Int}(undef, length(reverse!(arr)))
    for (i, num) in enumerate(arr)
        loc = search_left_border(1, length(queue), x -> queue[x] >= num)
        res[i] = loc - 1
        insert!(queue, loc, num)
    end
    reverse!(arr)
    return reverse!(res)
end"
"function increasing_bst(root::TreeNode{Int})
    p = TreeNode(0)
    q = p
    function mid_tranv(root::TreeNode{Int})
        (root.left !== nothing) && mid_tranv(root.left)
        q.right = TreeNode(root.val)
        q = q.right
        (root.right !== nothing) && mid_tranv(root.right)
        nothing
    end
    mid_tranv(root)
    p.right
end"
"function findContentChildren(g::Vector{Int}, s::Vector{Int})::Int
    sort!(g)
    sort!(s)

    child, cookie = 1, 1

    while child <= length(g) && cookie <= length(s)
        if g[child] <= s[cookie]
            child += 1
        end
        cookie += 1
    end

    return child - 1
end"
"function can_finish_courses(num_courses, prerequisites::Vector{Vector{Int}})
    in_deg = fill(0, num_courses)
    point_to = [Int[] for _ in 1:num_courses] # fill(Int[], num_courses) is not proper!
    for edge in prerequisites
        in_deg[edge[1]] += 1
        push!(point_to[edge[2]], edge[1])
    end
    q = Queue{Int}()
    for idx in 1:length(in_deg)
        (in_deg[idx] == 0) && (enqueue!(q, idx))
    end
    while !isempty(q)
        frt = dequeue!(q)
        for pt in point_to[frt]
            (in_deg[pt] -= 1) == 0 && enqueue!(q, pt) 
        end
    end
    return all(==(0), in_deg)
end"
"function rotated_digits(N::Int)
    if N <= 9
        return count(==(1), [0, 1, -1, -1, 1, 1, -1, 0, 1][1:N])
    end
    ans, dp = 0, vcat([0, 0, 1, -1, -1, 1, 1, -1, 0, 1], fill(0, N - 9))
    for i in 1:N-1
        dp[i + 1] = (-1 in [dp[i ÷ 10 + 1], dp[i % 10 + 1]]) ? -1 : (dp[i ÷ 10 + 1] | dp[i % 10 + 1])
        ans += (dp[i + 1] == 1)
    end
    ans
end"
"function unique_path_with_obstacles_63!(obstacleGrid::Vector{Vector{Int}})::Int
    m, n = length(obstacleGrid), length(obstacleGrid[1])
    obstacleGrid[1][1] = 1 - obstacleGrid[1][1]
    for i in 2:n
        obstacleGrid[1][i] = obstacleGrid[1][i] == 1 ? 0 : obstacleGrid[1][i - 1]
    end
    for i in 2:m
        obstacleGrid[i][1] = obstacleGrid[i][1] == 1 ? 0 : obstacleGrid[i - 1][1]
    end
    for i in 2:m
        for j in 2:n
            obstacleGrid[i][j] = if obstacleGrid[i][j] == 1
                0
            else
                obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]
            end
        end
    end
    return obstacleGrid[end][end]
end
function unique_path_with_obstacles_63(obstacleGrid::Vector{Vector{Int}})
    return unique_path_with_obstacles_63!(copy(obstacleGrid))
end"
"using DataStructures

function find_word_concatenation(s::String, words::Vector{String})::Vector{Int}
    (length(words) == 0 || length(words[1]) == 0) && return 0
    words_map = counter(words)
    results_indices = Int[]
    word_len, words_count = length(words[1]), length(words)

    for i in 1: (length(s) - word_len * words_count + 1)
        words_seen = DefaultDict{String, Int}(0)
        for j in 0: words_count - 1
            next_word_index = i + j * word_len
            ## Get the next word from the string
            word = s[next_word_index: next_word_index + word_len - 1]
            ## Break if we don't need this word
            !haskey(words_map, word) && break
            ## Add the word to the 'words_seen' map
            words_seen[word] += 1
            ## No need to process further if the word has higher frequency than required
            words_seen[word] > get(words_map, word, 0) && break

            ## Store index if we have found all the words
            (j + 1 == words_count) && push!(results_indices, i)
        end
    end

    return results_indices
end"
"function character_replacement(s::String, k::Int)
    i, j, len, maxn = 1, 1, length(s), 0
    cntr = fill(0, 26)
    while j ≤ len
        maxn = max(maxn, cntr[s[j] - 'A' + 1] += 1)
        if maxn + k < j - i + 1
            cntr[s[i] - 'A' + 1] -= 1
            i += 1
        end
        j += 1
    end
    j - i
end"
"function partition_ps132(s::String)
    len = length(s)
    is_ps = fill(true, len, len)
    dp = fill(typemax(Int) >> 4, len)
    dp[1] = 0
    for i in len:-1:1, j in (i + 1):len
        is_ps[i, j] = (s[i] == s[j]) && is_ps[i + 1, j - 1]
    end
    for i in 2:len
        if is_ps[1, i]
            dp[i] = 0
        else
            for j in 2:i
                (is_ps[j, i]) && (dp[i] = min(dp[i], dp[j - 1] + 1))
            end
        end
    end
    return dp[end]
end"
"function find_max_consecutive_ones(nums::Vector{Int})
    cnt, tmp = 0, 0
    for num in nums
        num == 1 ? tmp += 1 : tmp = 0
        cnt = max(tmp, cnt)
    end
    return max(tmp, cnt)
end"
"function is_unival_tree(root::TreeNode)
    is_unival_tree(::Nothing, ::Int) = true
    is_unival_tree(root::TreeNode, val::Int) = 
        (root.val != val) ? false :
               is_unival_tree(root.left, val) && is_unival_tree(root.right, val)
    return is_unival_tree(root, root.val)
end"
"## use Trie
longest_common_word(words::Vector{String}) = longest_common_word!(words)
function longest_common_word!(words::Vector{String})::String
    root, res = Dict{Char,Dict}(), """"
    for word in sort!(words; by=length)
        node, n = root, length(word)
        for (i, c) in enumerate(word)
            if haskey(node, c)
                node = node[c]
            elseif i == n
                node[c] = Dict{Char,Dict}() ## add new child
                res = word
            else
                break
            end
        end
    end
    return res
end"
"function base_neg2(N::Int)
    cnt = 0
    res = """"
    while N > 0
        bit = (N & 1)
        N -= bit * (-1) ^ cnt
        N >>= 1
        cnt += 1
        res = string(bit) * res
    end
    res
end"
"serialize(::Nothing) = ""[]""
function serialize(root::TreeNode{Int})::String
    res, queue, hasnew = String[], Union{TreeNode,Nothing}[root], true
    while hasnew
        hasnew = false
        for _ in 1:length(queue)
            node = popfirst!(queue)
            if !isnothing(node)
                push!(res, string(node.val))
                push!(queue, node.left)
                push!(queue, node.right)
                all(isnothing.([node.left, node.right])) || (hasnew = true)
            else
                push!(res, ""null"")
            end
        end
    end
    return ""["" * join(res, ',') * ""]""
end

function deserialize(data::String)::Union{TreeNode,Nothing}
    data == ""[]"" && return nothing
    vals = split(data[2:(end - 1)], ',')
    root, n = TreeNode(parse(Int, vals[1])), length(vals)
    queue, m = [root], 2
    while m <= n
        for _ in 1:length(queue) ## new nodes
            node = popfirst!(queue)
            if vals[m] != ""null""
                node.left = TreeNode(parse(Int, vals[m]))
                push!(queue, node.left)
            end
            if vals[m + 1] != ""null""
                node.right = TreeNode(parse(Int, vals[m + 1]))
                push!(queue, node.right)
            end
            m += 2
        end
    end
    return root
end"
"function repeated_string_match(a::String, b::String)
    minres = (length(b) - 1) ÷ length(a) + 1
    s = a ^ minres
    for i in 0:2
        occursin(b, s) && return minres + i
        s *= a
    end
    return -1
end"
"function merge_sorted_array(
    nums1::AbstractVector{Int}, m::Int, nums2::AbstractVector{Int}, n::Int
)::Nothing
    i = m + n
    while m > 0 && n > 0
        if nums1[m] > nums2[n]
            nums1[i] = nums1[m]
            m -= 1
        else
            nums1[i] = nums2[n]
            n -= 1
        end
        i -= 1
    end

    while n > 0
        nums1[i] = nums2[n]
        n -= 1
        i -= 1
    end

    return nothing
end"
"function push_dominoes(dominoes::String)::String
    ans = """"
    rules = (""R.L"" => ""T"", "".L"" => ""LL"", ""R."" => ""RR"", ""T"" => ""R.L"")
    while dominoes != ans
        ans = dominoes
        dominoes = foldl(replace, [dominoes, rules...])
    end
    return ans
end"
"function check_record(n::Int)
    P = [1 1 0 1 0 0
        1 0 1 1 0 0
        1 0 0 1 0 0
        0 0 0 1 1 0
        0 0 0 1 0 1
        0 0 0 1 0 0]
    res = mat_fast_mul(P, n, Int(1e9 + 7))
    sum(@view res[1, :]) % Int(1e9 + 7)
end"
"function monotone_increasing_digits(N::Int)::Int
    some_ones = 111111111
    res = 0
    for _ in 1:9 
        while res + some_ones > N
            some_ones ÷= 10           
        end
        res += some_ones
    end
    return res
end"
"function delete_and_earn(nums::Vector{Int})
    if length(nums) == 0
        return 0
    elseif length(nums) == 1
        return nums[1]
    end
    cntr = fill(0, maximum(nums))
    for num in nums
        cntr[num] += num
    end
    fst, scd = cntr[1], max(cntr[2], cntr[1])
    for i in 3:length(cntr)
        fst, scd = scd, max(fst + cntr[i], scd)
    end
    return scd
end"
"function knight_probability(n::Int, k::Int, row::Int, col::Int)
    dp = fill(0, n, n, 2)
    dp[row + 1, col + 1, 1] = 1
    for i in 1:k
        dp1 = @view(dp[:, :, mod1(i, 2)])
        dp2 = @view(dp[:, :, mod1(i + 1, 2)])
        idcs = CartesianIndices(dp2)
        for I in idcs, hop in ((1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1))
            new_I = I + CartesianIndex(hop) 
            new_I ∈ idcs && (dp2[new_I] += dp1[I])            
        end
        fill!(dp1, 0)
    end
    return sum(dp) / 8 ^ k
end"
"function calculate_ii(s::String)::Int
    num, stk, sign = 0, Int64[], '+'

    for (i, c) in enumerate(s)
        isdigit(c) && (num = 10 * num + parse(Int, c))
        if c in ['-', '+', '/', '*'] || i == length(s)
            if sign == '+'
                push!(stk, num)
            elseif sign == '-'
                push!(stk, -num)
            elseif sign == '*'
                push!(stk, pop!(stk) * num)
            elseif sign == '/'
                push!(stk, pop!(stk) ÷ num)
            end

            num = 0
            sign = c
        end
    end

    return sum(stk)
end"
"## simulate Mathematica's function NestWhileList
function nest_while_list(f::Function, val::T, chk::Function)::Vector{T} where {T}
    res = [val]
    while chk(val)
        val = f(val)
        push!(res, val)
    end
    return res
end

trailing_zeroes(n::Int) = sum(nest_while_list(i -> i ÷ 5, n ÷ 5, >(1)))
## equivalent to the following
## function trailing_zeroes(n::Int)::Int
##     res = 0
##     while n >=5
##         n ÷= 5
##         res += n
##     end
##     res
## end"
"## double pointer
function reformatstr(s::AbstractString)
    n = length(s) + 1
    res = Vector{Char}(undef, n)
    odd, even = 1, 2
    for c in s
        if isdigit(c)
            odd > n && return """"
            res[odd] = c
            odd += 2
        else
            even > n && return """"
            res[even] = c
            even += 2
        end
    end
    abs(even - 1 - odd) > 2 && return """"
    max(odd, even) < n + 2 && return join(@view(res[1:(end - 1)]))
    return last(res) * join(@view(res[1:(end - 2)]))
end"
"function is_word_exist(board::Matrix{Char}, word::String)
    function _backtracking_search(board::Matrix{Char}, word::String, pos::CartesianIndex{2},
                                  depth::Int)::Bool
        depth > length(word) && return true
        (pos ∉ CartesianIndices(board) || board[pos] != word[depth]) && return false
        board[pos] += 256
        res = _backtracking_search(board, word, pos + CartesianIndex(1, 0), depth + 1) ||
              _backtracking_search(board, word, pos + CartesianIndex(-1, 0), depth + 1) ||
              _backtracking_search(board, word, pos + CartesianIndex(0, 1), depth + 1) ||
              _backtracking_search(board, word, pos + CartesianIndex(0, -1), depth + 1)
        board[pos] -= 256
        return res
    end
    for idx in CartesianIndices(board)
        _backtracking_search(board, word, idx, 1) && return true
    end
    return false
end"
"function integer_replacement(n::Int)
    res = 0
    while n != 1
        if iseven(n)
            n >>= 1
        else
            n += (n & 2 == 0 || n == 3) ? -1 : 1
        end
        res += 1
    end
    return res
end"
"function max_profit_309(prices)
    isempty(prices) && return 0
    ## f0: this day I have a stock
    ## f1: this day I sell a stock
    ## f2: this day I can buy the stock
    f0, f1, f2 = -first(prices), 0, 0
    for price in @view(prices[2:end])
        f0, f1, f2 = max(f2 - price, f0), f0 + price, max(f1, f2)        
    end
    return max(f1, f2)
end"
"function shortest_common_supersequence(str1::String, str2::String)
    m, n = length(str1), length(str2)
    dp = OffsetArray(fill(0, m + 1, n + 1), -1, -1)
    for i in 1:m, j in 1:n
        dp[i, j] = max(
            dp[i - 1, j], dp[i, j - 1], dp[i - 1, j - 1] + Int(str1[i] == str2[j])
        )
    end
    res = """"
    coord = CartesianIndex(m, n)
    while coord != CartesianIndex(0, 0)
        c1 = coord - CartesianIndex(1, 0)
        c2 = coord - CartesianIndex(0, 1)
        if c1 ∈ CartesianIndices(dp) && dp[coord] == dp[c1]
            res *= str1[coord[1]]
            coord -= CartesianIndex(1, 0)
        elseif c2 ∈ CartesianIndices(dp) && dp[coord] == dp[c2]
            res *= str2[coord[2]]
            coord -= CartesianIndex(0, 1)
        else
            res *= str1[coord[1]]
            coord -= CartesianIndex(1, 1)
        end
    end
    return reverse(res)
end"
"struct ParkingSystem
    A::Vector{Int}
    ParkingSystem(big, median, small) = new([big, median, small])
end

function add_car(parking::ParkingSystem, car_type::Int)::Bool
    parking.A[car_type] -= 1
    return parking.A[car_type] >= 0
end"
divisor_game(n::Int) = iseven(n)
"function garden_no_adj(n::Int, path::Vector{Vector{Int}})
    G = Dict{Int,Set{Int}}()
    for (u, v) in path
        push!(get!(G, u, Set{Int}()), v)
        push!(get!(G, v, Set{Int}()), u)
    end
    res = zeros(Int, n)
    for i in 1:n
        res[i] = first(setdiff(1:4, [res[j] for j in G[i]]))
    end
    return res
end"
"function grid_illumination(N, lamps::Vector{Tuple{Int,Int}}, query::Vector{Tuple{Int,Int}})
    function update!(lamp, q)
        col_illum[lamp[2]] += q
        row_illum[lamp[1]] += q
        main_diag_illum[lamp[2]-lamp[1]] += q
        d_diag_illum[lamp[2]+lamp[1]] += q
    end
    dirs = [
        -1 -1 -1 0 0 0 1 1 1
        1 0 -1 1 0 -1 1 0 -1
    ]
    col_illum = DefaultDict{Int,Int}(0)
    row_illum = DefaultDict{Int,Int}(0)
    main_diag_illum = DefaultDict{Int,Int}(0)
    d_diag_illum = DefaultDict{Int,Int}(0)
    illum_pos = Set(lamps)
    res = fill(0, length(query))
    for lamp in lamps
        update!(lamp, 1)
    end
    for (idx, q) in enumerate(query)
        if col_illum[q[2]] > 0 ||
           row_illum[q[1]] > 0 ||
           main_diag_illum[q[2]-q[1]] > 0 ||
           main_diag_illum[q[2]+q[1]] > 0
            res[idx] = 1
        end
        for dir in 1:9
            new_pos = (q[1] + dirs[1, dir], q[2] + dirs[2, dir])
            if new_pos in illum_pos
                pop!(illum_pos)
                update!(new_pos, -1)
            end
        end
    end
    res
end"
"using DataStructures

struct MyQueue
    in_stack::Vector{Int}
    out_stack::Vector{Int}
    MyQueue() = new(Int[], Int[])
end


## Push element x to the back of queue.
myqueue_push!(queue::MyQueue, x::Int) = push!(queue.in_stack, x)

## Removes the element from in front of queue and returns that element.
function myqueue_pop!(queue::MyQueue)
    myqueue_move!(queue)

    return pop!(queue.out_stack)
end

## Get the front element.
function myqueue_peek(queue::MyQueue)
    myqueue_move!(queue)
    return queue.out_stack[end]
end

## Returns whether the queue is empty.
myqueue_isempty(queue::MyQueue) = isempty(queue.in_stack) && isempty(queue.out_stack)

function myqueue_move!(queue::MyQueue)
    if isempty(queue.out_stack)
        while !isempty(queue.in_stack)
            push!(queue.out_stack, pop!(queue.in_stack))
        end
    end
end"
"function subsets(arr::Vector{T}) where T
    res = [T[]]
    for e in arr
        for i in eachindex(res)
            push!(res, vcat(res[i], e))
        end
    end
    res
end

## add your code here:"
"function count_vowel_permutation(n::Int)::Int
    table = Dict{Char,Int}(i => 1 for i in ""aeiou"")
    quotient = 10^9 + 7
    for _ in 1:(n - 1)
        a = table['e'] + table['i'] + table['u']
        e = table['a'] + table['i']
        i = table['e'] + table['o']
        o = table['i']
        u = table['i'] + table['o']
        table['a'], table['e'], table['i'], table['o'], table['u'] = map(
            x -> mod(x, quotient), [a, e, i, o, u]
        )
    end
    return mod(sum(values(table)), quotient)
end"
"function reverse_between(head::ListNode{Int}, m::Int, n::Int)::ListNode
    (isnothing(head) || m == n) && return head
    p = dummy = ListNode()
    next!(dummy, head)
    for _ = 1:m-1
        p = next(p)
    end

    tail = next(p)

    for _ = 1:n-m
        tmp = next(p)
        next!(p, next(tail))
        next!(tail, next(next(tail)))
        next!(next(p), tmp)
    end

    return next(dummy)
end"
"function is_cousins(root::TreeNode{Int}, x, y)
    q = NTuple{2, Union{Nothing, TreeNode}}[]
    push!(q, (root, nothing))
    while !isempty(q)
        n = length(q)
        rec_parent = TreeNode{Int}[]
        for i in 1:n
            cur, par = popfirst!(q)
            if cur.val == x || cur.val == y
                push!(rec_parent, par)
            end
            isnothing(cur.left) || push!(q, (cur.left, cur))
            isnothing(cur.right) || push!(q, (cur.right, cur))
        end
        length(rec_parent) == 0 && continue
        length(rec_parent) == 1 && return false
        length(rec_parent) == 2 && return rec_parent[1] != rec_parent[2]        
    end
end"
"using OffsetArrays
function h_index(citations::Vector{Int})::Int
    len = length(citations)
    cnt = OffsetArray(fill(0, len + 1), -1)
    for c in citations
        cnt[min(c, len)] += 1        
    end
    c = 0
    for i in Iterators.reverse(eachindex(cnt))
        c += cnt[i]
        c == i && return i
    end
end"
"function max_path_sum(root::TreeNode)
    max_val = typemin(Int)

    function max_sum_to_leaf(x)
        isnothing(x) && return 0
        left = max_sum_to_leaf(x.left)
        right = max_sum_to_leaf(x.right)
        max_val = max(max_val, left + x.val + right)
        return max(0, x.val + max(left, right))
    end

    max_sum_to_leaf(root)
    return max_val
end"
"function count_substrings(s::String, t::String)
    function count_substr(s::SubString{String}, t::String)
        res, len_s, len_t = 0, length(s), length(t)
        for i in 1:len_t
            j, k, diff = 1, i, 0
            while diff < 2 && j <= len_s && k <= len_t 
                res += diff
                diff += (s[j] != t[k])
                j += 1; k += 1;
            end
            res += (diff == 1)
        end
        res
    end 
    res = 0
    for i in 1:length(s)
        res += count_substr(SubString(s, i), t)
    end
    return res
end"
"function is_robot_bounded(instructions::String)::Bool
    pos = CartesianIndex(0, 0)
    dirs = CartesianIndex.([(0, 1), (1, 0), (0, -1), (-1, 0)])
    st = 1
    for ch in instructions
        if ch == 'G'
            pos += dirs[st]
        else
            st = mod1(st + (ch == 'R' ? 1 : -1), 4)
        end
    end
    return pos.I == (0, 0) || st != 1
end"
"function pivot_index(nums::Vector{Int})
    if isempty(nums)
        return 0
    end
    total = sum(nums)
    left, right = 0, total
    for i in 1:length(nums) 
        right -= nums[i]
        if left == right
            return i
        end
        left += nums[i]
    end
    return (left == nums[end]) ? length(nums) : 0
end"
"function daily_temperatures(T::Vector{Int})
    res = fill(0, length(T))    
    stk = Int[]
    for i in 1:length(T)
        while !isempty(stk) && T[stk[end]] < T[i]
            res[stk[end]] = i - stk[end]
            pop!(stk)
        end
        push!(stk, i)
    end
    res
end"
"struct NumArray
    sums::Vector
    function NumArray(nums::Vector)
        n = length(nums)
        sums = nums[:]

        for i = 2:n
            sums[i] = sums[i-1] + nums[i]
        end
        new(sums)
    end
end

function sum_range(nums::NumArray, i::Int, j::Int)
    i == j && return 0
    i == 1 && return nums.sums[j]
    return nums.sums[j] - nums.sums[i-1]
end"
"function single_number_iii(nums::Vector{T}) where T <: Integer 
    res = reduce(⊻, nums; init = zero(T))
    div = one(T)
    while (div & res) == 0
        div <<= one(T)
    end
    a = b = 0
    for n in nums
        (div & n == 0) ? a ⊻= n : b ⊻= n 
    end
    return a, b
end"
"four_sum(nums::Vector{Int}, target::Int) = four_sum!(copy(nums), target)
function four_sum!(nums::Vector{Int}, target::Int)::Vector{NTuple{4,Int}}
    n, res = length(sort!(nums)), NTuple{4,Int}[]
    n <= 3 && return NTuple{4,Int}[]
    for (i, first) in enumerate(@view(nums[1:(end - 3)]))
        i > 1 && first == nums[i - 1] && continue ## avoid repetition
        sum(@view(nums[i:(i + 3)])) > target && return res ## pruning
        first + sum(@view(nums[(end - 3):end])) < target && continue ## pruning
        for j in (i + 1):(n - 2)
            j > i + 1 && nums[j] == nums[j - 1] && continue ## avoid repetition
            first + sum(@view(nums[j:(j + 2)])) > target && break ## pruning
            first + nums[j] + nums[end - 1] + nums[end] < target && continue ## pruning
            newtarget = target - first - nums[j]
            left, right = j + 1, n
            while left < right
                newsum = nums[left] + nums[right]
                if newsum < newtarget
                    left += 1
                elseif newsum > newtarget
                    right -= 1
                else
                    push!(res, (first, nums[j], nums[left], nums[right]))
                    pos = findfirst(!=(nums[left]), @view(nums[(left + 1):right]))
                    isnothing(pos) ? break : (left += pos)
                    pos = findfirst(!=(nums[right]), @view(nums[(right - 1):-1:left]))
                    isnothing(pos) ? break : (right -= pos)
                end
            end
        end
    end
    return res
end"
"function max_envelopes(envelopes::Vector{Vector{Int}})
    isempty(envelopes) && return 0
    sort!(envelopes, by = x -> (x[1], -x[2]))
    dp = [envelopes[1][2]]
    for envo in @view(envelopes[2:end])
        if envo[2] > dp[end]
            push!(dp, envo[2])
        else
            dp[searchsortedfirst(dp, envo[2])] = envo[2]
        end
    end
    length(dp)
end"
"function num_rabbits(answer::Vector{Int})
    cnt = counter(answer)
    res = 0
    for (key, v) in cnt
        res += ((v - 1) ÷ (key + 1) + 1) * (key + 1)
    end
    res
end"
"function query_string(S::String, N::Int)
    m = (N >> 1) + 1
    for i in m:N
        s_bit = join(reverse!(digits(i; base=2)))
        !occursin(s_bit, S) && return false
    end
    return true
end"
"mutable struct MyCircularQueue
    len::Int
    front::Int
    rear::Int
    arr::Vector{Int} ## use one extra position
    MyCircularQueue(k::Int)  = new(k + 1, 1, 1, Vector{Int}(undef, k + 1))
end

is_full(que::MyCircularQueue) = (que.rear + 1 - que.front) % que.len == 0

function en_queue(que::MyCircularQueue, val::Int)
    is_full(que) && return false
    que.arr[que.rear] = val
    que.rear = que.rear % que.len + 1
    return true
end

is_empty(que::MyCircularQueue) = que.front == que.rear

function de_queue(que::MyCircularQueue)
    is_empty(que) && return false
    que.front = que.front % que.len + 1
    return true
end

front(que::MyCircularQueue) = is_empty(que) ? -1 : que.arr[que.front]
function rear(que::MyCircularQueue)
    is_empty(que) && return -1
    return que.arr[mod(que.rear - 2, que.len) + 1] ## use mod instead of % to avoid negative number
end"
"_sum_root_to_leaf(::Nothing) = (0, 0)
function _sum_root_to_leaf(root::TreeNode{Int})
    lft, rgt = _sum_root_to_leaf(root.left), _sum_root_to_leaf(root.right)
    tms = max(1, lft[2] + rgt[2])
    return (lft[1] + rgt[1]) + tms * root.val, tms * 2
end

sum_root_to_leaf(root::TreeNode{Int}) = _sum_root_to_leaf(root)[1]

## BFS Algorithm
## sum_root_to_leaf_bfs(::Nothing) = 0 # unnecessary
function sum_root_to_leaf_bfs(root::TreeNode)
    queue, res = [(root.val, root)], 0
    while !isempty(queue)
        for _ in 1:length(queue)
            val, node = popfirst!(queue)
            if isnothing(node.left) && isnothing(node.right)
                res += val
            else
                !isnothing(node.left) && push!(queue, (val << 1 + node.left.val, node.left))
                !isnothing(node.right) &&
                    push!(queue, (val << 1 + node.right.val, node.right))
            end
        end
    end
    return res
end"
"## add your code here:
function can_reorder_doubled(arr::Vector{Int})::Bool
    cnt = counter(arr)
    for a in sort!(arr; by=abs)
        cnt[a] == 0 && continue
        cnt[2a] == 0 && return false
        cnt[2a] -= 1
        cnt[a] -= 1
    end
    return true
end"
"function find_cheapest_price(n::Int, flights::Vector{Vector{Int}}, src::Int, dst::Int, K::Int)
    graph = [Dict{Int, Int}() for i in 1:n]
    for flight in flights
        graph[flight[1]][flight[2]] = flight[3]
    end
    cost = fill(typemax(Int) >> 1, n)
    cost[src] = 0
    changed = [src]
    for i in 1:K+1
        tmp = Int[]
        for new_s in changed
            for (s_to_t, st_cost) in graph[new_s]
                if cost[s_to_t] > st_cost + cost[new_s]
                    cost[s_to_t] = st_cost + cost[new_s]
                    push!(tmp, s_to_t)
                end
            end
        end
        changed = tmp
    end
    return (cost[dst] == typemax(Int) >> 1) ? -1 : cost[dst]
end"
"function min_moves2(nums::Vector{Int})
    median = partialsort!(nums, (length(nums) + 1) ÷ 2)
    return sum(abs, num - median for num in nums)
end"
"pascals_triangle(numRows::Int) = [[binomial(k, i) for i in 0:k] for k in 0:(numRows - 1)]"
"function remove_duplicates2!(nums::Vector{Int})::Int
    j = 3
    for i in 3:length(nums)
        if nums[i] != nums[j - 2]
            nums[j] = nums[i]
            j += 1
        end
    end

    return j - 1
end"
"function find_length_of_lcis(nums::Vector{Int})
    res, tmp = 0, 1
    for i in 2:length(nums)
        if nums[i] > nums[i - 1]
            tmp += 1
        else
            res = max(res, tmp)
            tmp = 1            
        end
    end
    min(max(tmp, res), length(nums))
end"
"function max_profit714(price::Vector{Int}, fee::Int)::Int
    dp1, dp2 = 0, -50000
    for p in price
        dp1, dp2 = max(dp1, dp2 + p - fee), max(dp2, dp1 - p)
    end
    return dp1
end"
"function max_equal_rows_after_flips(mat::Matrix{Int})
    mp = Dict{Vector{Int}, Int}()
    for row in eachrow(mat)
        row[1] == 1 && (row .= 1 .- row)
        mp[row] = get(mp, row, 0) + 1
    end
    return maximum(values(mp))
end"
"function eval_rpn(tokens::Vector{String})
    stk = Stack{Int}()
    for token in tokens
        if token == ""+""
            num2 = pop!(stk)
            num1 = pop!(stk)
            push!(stk, num1 + num2)
        elseif token == ""-""
            num2 = pop!(stk)
            num1 = pop!(stk)
            push!(stk, num1 - num2)
        elseif token == ""*""
            num2 = pop!(stk)
            num1 = pop!(stk)
            push!(stk, num1 * num2)
        elseif token == ""/""
            num2 = pop!(stk)
            num1 = pop!(stk)
            push!(stk, num1 ÷ num2)
        else
            push!(stk, parse(Int, token))
        end
    end
    first(stk)
end"
"function reverse_integer(x::Int32)::Int
    s = sign(x)
    r = parse(Int, reverse(string(s * x)))
    return r <= typemax(Int32) ? s * r : 0
end"
"function escape_ghosts(ghosts::Vector{Vector{Int}}, target::Vector{Int})
    dist1 = sum(abs, target)
    dist2 = minimum(sum(abs, g .- target) for g in ghosts)
    return dist1 < dist2
end"
"function frequency_sort(s::String)
    u_vec = codeunits(s)[:]
    freq = fill(0, 128)
    for n in codeunits(s)
        freq[n] += 1
    end
    sort!(u_vec; by=x -> (freq[x], x), rev = true)
    String(u_vec)
end"
"function lowest_common_ancestor_235(root::TreeNode, p::TreeNode, q::TreeNode)::TreeNode
    lv, gv = p.val < q.val ? (p.val, q.val) : (q.val, p.val)
    while true
        lv <= root.val <= gv && return root
        root = root.val < lv ? root.right : root.left
    end
end"
"function min_operations_1551(n::Int)
    return 2 * sum(1 : (n - 1) ÷ 2) + (n & 1 == 0) * (n ÷ 2)
end"
"function min_deletion_size(A::Vector{String})
    word_len = length(A[1])
    dp = fill(1, word_len)    
    for i in word_len - 1 : -1 : 1
        for j in i + 1 : word_len
            all(word[i] < word[j] for word in A) && (dp[i] = max(dp[i], dp[j] + 1))
        end
    end
    word_len - maximum(dp)
end"
"## Dynamic Programming
function min_cost_climbing_stairs(cost::Vector{Int})::Int
    first, second = cost[1], cost[2]
    for c in @view cost[3:end]
        first, second = second, min(first, second) + c
    end
    return min(first, second)
end"
"function combination_sum4(nums::Vector{Int}, target::Int)
    dp = OffsetArray(fill(0, target + 1), -1)
    dp[0] = 1
    for i in 1:target, num in nums
        (num <= i) && (dp[i] += dp[i - num])
    end
    return dp[end]
end"
"function minimum_delete_sum(s1::String, s2::String)
    m, n = length(s1) + 1, length(s2) + 1
    dp = fill(0, m, n)
    dp[2:end, 1] .= cumsum(codeunits(s1))
    dp[1, 2:end] .= cumsum(codeunits(s2))
    for i in 2:m, j in 2:n
        dp[i, j] = (s1[i - 1] == s2[j - 1]) ? (dp[i - 1, j - 1]) :
                   min(dp[i - 1, j] + Int(s1[i - 1]), dp[i, j - 1] + Int(s2[j - 1]))
    end
    return dp[m, n]
end"
"function find_latest_step(arr::Vector{Int}, m::Int)
    pos_dict = Dict{Int, Int}()
    neg_dict = Dict{Int, Int}()
    cnt = 0
    res = -1
    for (idx, num) in enumerate(arr)
        pos_dict[num] = num
        neg_dict[num] = num
        if haskey(pos_dict, num + 1)
            (pos_dict[num + 1] - num == m) && (cnt -= 1)
            tmp = pop!(pos_dict, num + 1)
            pos_dict[num] = tmp
            neg_dict[tmp] = num
        end
        if haskey(neg_dict, num - 1)
            (num - neg_dict[num - 1] == m) && (cnt -= 1)
            tmp = pop!(neg_dict, num - 1)
            neg_dict[num] = tmp
            pos_dict[tmp] = num
        end
        pos_dict[neg_dict[num]], neg_dict[pos_dict[num]] = pos_dict[num], neg_dict[num] 
        (pos_dict[neg_dict[num]] - neg_dict[num] + 1 == m) && (cnt += 1)
        (cnt > 0) && (res = idx)
        if pos_dict[neg_dict[num]] != num 
            pop!(pos_dict, num)
            pop!(neg_dict, num)
        end
    end
    return res
end"
"preorder_traversal(::Nothing) = Int[]
function preorder_traversal(root::TreeNode)::Vector{Int}
    res, stack = Int[], []
    while !isempty(stack) || !isnothing(root)
        while !isnothing(root)
            push!(stack, root)
            push!(res, root.val) ## preorder search
            root = root.left
        end
        root = pop!(stack)
        root = root.right
    end
    return res
end

##### code template for inorder traversal and preorder traversal #####
## traversal(::Nothing) = Int[]
## function traversal(root::TreeNode)::Vector{Int}
##     res, stack = Int[], []
##     while !isempty(stack) || !isnothing(root)
##         while !isnothing(root)
##             push!(stack, root)
##             ## preorder traversal: put codes here
##             root = root.left
##         end
##         root = pop!(stack) 
##         ## inorder traversal: put codes here
##         root = root.right
##     end
##     res
## end"
"function find_rotate_steps(ring::String, key::String)
    lenr, lenk = length(ring), length(key)
    dp1 = fill(typemax(Int), lenr)
    dp2 = dp1[:]
    mp = [Int[] for i in 1:26]
    for i in 1:lenr
        push!(mp[ring[i] - 'a' + 1], i)
    end
    for idx in mp[key[1] - 'a' + 1]
        dp1[idx] = min(idx - 1, lenr - idx)
    end
    for i in 2:lenk
        for idx1 in mp[key[i] - 'a' + 1]
            for idx2 in mp[key[i - 1] - 'a' + 1]
                dp2[idx1] = min(
                    dp2[idx1], dp1[idx2] + min(abs(idx2 - idx1), lenr - abs(idx2 - idx1))
                )
            end
        end
        dp1, dp2 = dp2, dp1
        dp2 .= typemax(Int)
    end
    return minimum(dp1) + lenk
end"
"function num_moves_stones(a::Int, b::Int, c::Int)
    a, b, c = sort([a, b, c])
    return (min(1, b - a - 1) + min(1, c - b - 1), c - a - 2)
end"
"function product_except_self(nums::Vector{Int})
    n = length(nums)
    left = right = 1
    res = fill(1, n)
    @inbounds for i in 1:n
        res[i] *= left
        left *= nums[i] 
        res[n - i + 1] *= right
        right *= nums[n - i + 1]  
    end
    return res
end"
"function reach_number(target::Integer)
    target = abs(target)
    k = 0
    while target > 0
        k += 1
        target = target - k
    end
    return iseven(target) ? k : k + 1 + k % 2
end"
bulb_switch(n::Int) = isqrt(n)
"function climbing_stairs(n::Int)::Int
    n == 1 && return 1
    a, b = 1, 2
    for _ in 3:n
        a, b = b, a + b
    end
    return b
end"
"function calculate(s::String)::Int
    res, num, sign, stk = 0, 0, 1, []
    for c in s
        if isdigit(c)
            num = 10 * num + parse(Int, c)
        elseif c in ['-', '+']
            res += num * sign
            num = 0
            sign = (c == '-') ? -1 : 1
        elseif c == '('
            push!(stk, res)
            push!(stk, sign)
            res, sign = 0, 1
        elseif c == ')'
            res += num * sign
            res *= pop!(stk)
            res += pop!(stk)
            num = 0
        end
    end

    return res + num * sign
end"
"function insert_into_max_tree(root::TreeNode{Int}, val::Int)
    tmp = TreeNode(val)
    if val > root.val 
        tmp.left = root
        return tmp
    end
    root.right = insert_into_max_tree(root.right, val)
    return root
end
insert_into_max_tree(::Nothing, val::Int) = TreeNode(val)"
"function flip_and_invert_image(A::Vector{Vector{Int}})::Vector{Vector{Int}}
    m = length(A)
    for i = 1:m
        reverse!(A[i]) .⊻= 1
    end

    return A
end"
"remove_element!(nums::Vector{Int}, val::Int) = length(filter!(!=(val), nums))"
"function least_bricks(wall::Vector{Vector{Int}})
    tb = Dict{Int,Int}()
    for row in wall
        acc = 0
        for i in @view(row[1:(end - 1)])
            acc += i
            haskey(tb, acc) ? tb[acc] += 1 : tb[acc] = 1
        end
    end
    isempty(tb) && return length(wall)
    return length(wall) - maximum(values(tb))
end"
"function rob_198(nums::Vector{Int})::Int
    n = length(nums)
    n == 1 && return nums[1]
    first, second = nums[1], max(nums[1], nums[2])
    for num in @view nums[3:end]
        first, second = second, max(second, first + num)
    end
    return second
end"
"unique_paths(m::Int, n::Int) = binomial(m + n - 2, n - 1)"
"function sort_colors!(nums::Vector{Int})
    left = 1
    for i in eachindex(nums)
        if nums[i] == 0
            nums[i], nums[left] = nums[left], nums[i]
            left += 1
        end
    end
    for i in (left + 1):length(nums)
        if nums[i] == 1
            nums[i], nums[left] = nums[left], nums[i]
            left += 1
        end
    end
end"
"maximum_depth_of_btree(::Nothing) = 0
function maximum_depth_of_btree(root::TreeNode)
    return maximum(maximum_depth_of_btree, [root.left, root.right]) + 1
end"
", DataStructures

function oranges_rotting(grid::Vector{Vector{Int}})
    nr, nc = length(grid), length(grid[1])
    visited = fill(false, nr, nc)
    q = Queue{Tuple{Int,Int,Int}}()
    left, res = 0, 0
    for r in 1:nr, c in 1:nc
        if grid[r][c] == 2
            enqueue!(q, (r, c, 0))
        elseif grid[r][c] == 1
            left += 1
        end
    end
    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    while !isempty(q)
        tp = dequeue!(q)
        for dir in dirs
            nb = (tp[1] + dir[1], tp[2] + dir[2], tp[3] + 1)
            if 0 < nb[1] ≤ nr &&
               0 < nb[2] ≤ nc &&
               !visited[nb[1], nb[2]] &&
               grid[nb[1]][nb[2]] == 1
                left -= 1
                visited[nb[1], nb[2]] = true
                enqueue!(q, nb)
            end
        end
        res = tp[3]
    end
    left == 0 ? res : -1
end"
"function min_score_triangulation(values::Vector{Int})
    dp = fill(0, 50, 50)
    function dfs!(dp, i, j)
        j - i < 2 && return 0
        dp[i, j] > 0 && return dp[i, j]
        j - i == 2 && (return dp[i, j] = values[i] * values[i + 1] * values[j])
        v = values[i] * values[j]
        dp[i, j] = minimum(v * values[k] + dfs!(dp, i, k) + dfs!(dp, k, j) for k in i + 1:j - 1)
    end
    dfs!(dp, 1, length(values))
end"
"function find_the_difference(s::String, t::String)::Char
    cnt = fill(0, 26)
    for ch in codeunits(s)
        cnt[ch - 0x60] += 1
    end
    for ch in codeunits(t)
        if ((cnt[ch - 0x60] -= 1) < 0)
            return Char(ch)
        end
    end
end
find_the_difference_oneline(s::String, t::String) = Char(reduce(⊻, codeunits(s * t)))"
"function num_rescue_boats(people::Vector{Int}, limit::Int)
    sort!(people)
    a, b = 1, length(people)
    res = 0
    while a <= b
        res += 1
        a == b && break
        b -= 1
        (people[a] + people[b] <= limit) && (a += 1)
    end
    res
end"
"function num_jewels_in_stones(jewels::String, stones::String)
    mp = fill(0, 128)
    for i in codeunits(jewels) 
        mp[i] = 1        
    end
    sum(mp[i] for i in codeunits(stones))
end"
"function candy(ratings::Vector{Int})::Int
    sizes = length(ratings)
    if sizes < 2
        return sizes 
    end

    nums = ones(Int, sizes)
    ## from left to right 
    for i in 2: sizes
        if ratings[i] > ratings[i - 1]
            nums[i] = nums[i - 1] + 1
        end
    end

    ## from right to left
    for i in sizes: -1: 2
        if ratings[i] < ratings[i - 1]
            nums[i - 1] = max(nums[i - 1], nums[i] + 1)
        end
    end

    return sum(nums)
end"
"function tribonacci_1137(n::Int)::Int
    n <= 1 && return n
    a, b, c = 0, 1, 1
    for _ in 1:(n - 2)
        a, b, c = b, c, a + b + c
    end
    return c
end"
"function make_connected(n::Int, connections::Vector{Vector{Int}})
    if length(connections) < n - 1
        return -1
    end
    father = collect(1:n)
    find_root(u::Int)::Int = (father[u] == u) ? u : (father[u] = find_root(father[u]))
    issame_root(u::Int, v::Int)::Bool = find_root(u) == find_root(v)
    function merge(u::Int, v::Int)
        u_root = find_root(u)
        v_root = find_root(v)
        if u_root != v_root
            n -= 1
            father[u_root] = v_root
        end
    end
    for connection in connections
        merge(connection[1], connection[2])
    end
    return n - 1
end"
"function find_min_height_trees(n::Int, edges::Vector{Vector{Int}})
    (n == 1) && return [1]
    neighbor = [Set{Int}() for i in 1:n]
    for (u, v) in edges
        push!(neighbor[u], v)
        push!(neighbor[v], u)
    end
    q = [i for i in 1:n if length(neighbor[i]) == 1]
    dep_q = ones(Int, size(q))
    m_dep = 1
    visited = fill(false, n)
    visited[q] .= true
    res = q[:]
    while !isempty(q)
        u, dep = popfirst!(q), popfirst!(dep_q)
        for nei in neighbor[u]
            visited[nei] && continue
            visited[nei] = true
            push!(q, nei)
            push!(dep_q, dep + 1)
        end
        if dep > m_dep
            m_dep = dep
            res = [u; q]
        end
    end
    return res
end"
"function search_range(nums::Vector{Int}, target::Int)::Vector{Int}
    function get_left_border(target)
        left, right = 1, n
        while left <= right
            mid = (left + right) >> 1
            if nums[mid] >= target
                right = mid - 1
            else
                left = mid + 1
            end
        end
        return left
    end
    n = length(nums)
    left_border = get_left_border(target)
    (left_border > n || nums[left_border] != target) && return [-1, -1]
    return [left_border - 1, get_left_border(target + 1) - 2]
end"
"function ishappy(n::Int)::Bool
    while n != 1
        n == 4 && return false ## all loops must contain 4
        n = sum(digits(n) .^ 2)
    end
    return true
end"
"function judgePoint24(nums::Vector)::Bool
    n = length(nums)
    if n == 1
        return nums[1] == 24
    else
        for i in 1:n
            for j in 1:n
                if j != i
                    rest = [nums[k] for k in 1:n if k != i && k != j]
                    if judgePoint24([rest..., nums[i] + nums[j]]) ||
                       judgePoint24([rest..., nums[i] - nums[j]]) ||
                       judgePoint24([rest..., nums[j] - nums[i]]) ||
                       judgePoint24([rest..., nums[i] * nums[j]]) ||
                       (!iszero(nums[j]) && judgePoint24([rest..., nums[i]//nums[j]])) ||
                       (!iszero(nums[i]) && judgePoint24([rest..., nums[j]//nums[i]]))
                        return true
                    end
                end
            end
        end
        false
    end
end"
"function max_profit(prices::Vector{Int})::Int
    res = 0
    for i in 2:length(prices)
        res += (prices[i] > prices[i - 1]) ? (prices[i] - prices[i - 1]) : 0
    end
    return res
end"
"function find_number_of_LIS(nums::Vector{Int})
    len = length(nums)
    len <= 1 && return len
    dp = fill(1, len)
    cnt = copy(dp)
    for i in 2:len, j in 1:(i - 1)
        nums[i] <= nums[j] && continue
        if dp[i] <= dp[j]
            dp[i] = dp[j] + 1
            cnt[i] = cnt[j]
        elseif dp[i] == dp[j] + 1
            cnt[i] += cnt[j]
        end
    end
    max_len = maximum(dp)
    return sum(c for (idx, c) in enumerate(cnt) if dp[idx] == max_len)
end"
subtract_prod_sum(n::Int) = prod(digits(n)) - sum(digits(n))
"function min_subarray_len(s::Int, nums::Vector{Int})
    left = right = 1
    res = typemax(Int)
    len = length(nums)
    Σ = nums[1]
    while right <= len
        if Σ == s 
            res = min(res, right - left + 1)
            Σ -= nums[left]
            left += 1
            right += 1
            (right <= len) && (Σ += nums[right])
        elseif Σ < s
            right += 1
            (right <= len) && (Σ += nums[right])
        else 
            Σ -= nums[left]
            left += 1
        end
    end
    res
end"
"function tree_path_sum(root::TreeNode{Int}, sm::Int)::Int
    res = 0
    tsum(::Nothing, sm::Int) = nothing
    function tsum(root::TreeNode{Int}, sm::Int)::Nothing
        sm -= root.val
        sm == 0 && (res += 1)
        tsum(root.left, sm)
        tsum(root.right, sm)
    end
    tsum(root, sm)
    res += tree_path_sum(root.left, sm)
    res += tree_path_sum(root.right, sm)
end

tree_path_sum(root::Nothing, sum::Int) = 0"
"function max_increase_keeping_skyline(grid::Matrix{Int})
    n = size(grid, 1)
    col_max = maximum(grid; dims=1)
    row_max = maximum(grid; dims=2)
    res = 0
    for i in 1:n, j in 1:n
        res += min(row_max[i], col_max[j]) - grid[i, j]
    end
    return res
end"
"function can_three_parts_equal_sum(arr::Vector{Int})
    function can_three_parts_equal_sum(arr::AbstractVector{Int}, n::Int)
        targ = sum(arr)
        if targ % n != 0 || length(arr) == 0
            return false
        elseif n == 1
            return true
        end
        targ ÷= n
        acc = 0
        for i in 1:length(arr)
            acc += arr[i]
            targ == acc && return can_three_parts_equal_sum(@view(arr[(i + 1):end]), n - 1)
        end
        return false
    end
    return can_three_parts_equal_sum(arr, 3)
end"
"function wiggle_max_length(nums::Vector{Int})::Int
    len = length(nums)
    (len < 2) && return len

    pre_diff = nums[2] - nums[1]
    res = (pre_diff == 0 ? 1 : 2)
    for i in 3:len
        diff = nums[i] - nums[i - 1]
        if diff > 0 && pre_diff <= 0 || diff < 0 && pre_diff > 0
            res += 1
            pre_diff = diff
        end
    end
    return res
end"
"Base.@kwdef struct MinStack{V<:Number}
    nums::Vector{V} = Int[]
    min_nums::Vector{V} = Int[]
end

function Base.push!(stack::MinStack, val::Int)::Nothing
    Base.push!(stack.nums, val)
    if isempty(stack.min_nums) || val <= stack.min_nums[end]
        Base.push!(stack.min_nums, val)
    end
    return nothing
end

function Base.pop!(stack::MinStack)::Nothing
    if Base.pop!(stack.nums) == stack.min_nums[end]
        Base.pop!(stack.min_nums)
    end
    return nothing
end

top(stack::MinStack)::Int = stack.nums[end]

get_min(stack::MinStack)::Int = stack.min_nums[end]"
"function spellchecker(wordlist::Vector{String}, queries::Vector{String})
    wls = Set(wordlist)
    d1 = DefaultDict{String,Vector{Int}}(Vector{Int})
    d2 = deepcopy(d1)
    for (idx, word) in enumerate(wordlist)
        lc = lowercase(word)
        push!(d1[lc], idx)
        push!(d2[replace(lc, r""[eiou]"" => ""a"")], idx)
    end
    len = length(wordlist)
    res = fill("""", length(queries))
    for (idx, q) in enumerate(queries)
        lc = lowercase(q)
        lcy = replace(lc, r""[eiou]"" => ""a"")
        if q ∈ wls
            res[idx] = q
            continue
        elseif get(d1, lc, nothing) !== nothing
            res[idx] = wordlist[d1[lc][1]]
        elseif get(d2, lcy, nothing) !== nothing
            res[idx] = wordlist[d2[lcy][1]]
        end
    end
    return res
end"
"function max_area_of_container(height::Vector{Int})::Int
    i, j, res = 1, length(height), 0
    while i < j
        res = max(res, min(height[i], height[j]) * (j - i))
        height[i] < height[j] ? (i += 1) : (j -= 1)
    end
    return res
end"
"function average_salary_excluding_mami(salary::Vector{Int})
    return (sum(salary) - minimum(salary) - maximum(salary)) / (length(salary) - 2)
end"
"function longest_subarray(nums::Vector{Int}, limit::Int)
    queMin, queMax = Deque{Int}(), Deque{Int}()
    n = length(nums)
    left = right = 1
    res = 0

    while right <= n
        while !isempty(queMin) && !isempty(queMax) && last(queMax) < nums[right]
            pop!(queMax)
        end
        while !isempty(queMin) && !isempty(queMax) && last(queMin) > nums[right]
            pop!(queMin)
        end
        push!(queMax, nums[right])
        push!(queMin, nums[right])

        while !isempty(queMin) && !isempty(queMax) && first(queMax) - first(queMin) > limit
            if nums[left] == first(queMin)
                popfirst!(queMin)
            end
            if nums[left] == first(queMax)
                popfirst!(queMax)
            end
            left += 1
        end
        
        res = max(res, right - left + 1)
        right += 1
       
    end

    return res
end"
"function max_subarray_sum_circular(nums)
    length(nums) < 1 && return 0
    csum = cur_max = maxn = cur_min = minn = nums[1]
    for i in 2:length(nums)
        csum += nums[i]
        cur_max = (cur_max > 0) ? cur_max + nums[i] : nums[i]
        maxn = max(maxn, cur_max)
        cur_min = (cur_min < 0) ? cur_min + nums[i] : nums[i]
        minn = min(minn, cur_min)
    end
    return maxn < 0 ? maxn : max(csum - minn, maxn)
end"
"function min_cost1368(grid::Matrix)
    dx, dy = [1, -1, 0, 0], [0, 0, 1, -1]
    m, n = size(grid)
    dq = Deque{Tuple{Int,Int,Int}}()
    visited = fill(false, size(grid))
    pushfirst!(dq, (1, 1, 0))
    while !isempty(dq)
        x, y, w = popfirst!(dq)
        visited[x, y] && continue
        visited[x, y] = true
        (x == m && y == n) && return w
        for i in 1:4
            nx, ny = x + dx[i], y + dy[i]
            (1 <= nx <= m && 1 <= ny <= n) || continue
            grid[x, y] == i ? pushfirst!(dq, (nx, ny, w)) : push!(dq, (nx, ny, w + 1))
        end
    end
end"
"function num_equiv_domino_pairs(dominoes::Vector{Tuple{Int,Int}})::Int
    counts = Dict{Tuple{Int,Int},Int}()
    n = 0
    for (k, v) in dominoes
        p = minmax(k, v)
        if haskey(counts, p)
            n += counts[p]
            counts[p] += 1
        else
            counts[p] = 1
        end
    end
    return n
end"
"function flip_match_voyage(root::TreeNode, voyage::Vector{Int})
    res = Int[]
    i = 1
    dfs(::Nothing) = nothing
    function dfs(node::TreeNode)
        if node.val != voyage[i]
            res = [-1]
            return
        end
        i += 1
        if i ≤ length(voyage) && node.left !== nothing && node.left.val != voyage[i]
            push!(res, node.val)
            dfs(node.right)
            dfs(node.left)
        else
            dfs(node.left)
            dfs(node.right)
        end
    end
    dfs(root)
    return (!isempty(res) && res[1] == -1) ? [-1] : res
end"
"function count_digit_one(n::Int)::Int
    nums = reverse!([parse(Int, i) for i in string(n + 1)])
    res, ones = 0, count(==(1), nums)
    for (i, num) in enumerate(nums)
        num == 1 && (ones -= 1)
        res += 10^(i - 1) * (num * ones + (num > 1))
        res += i > 1 && (10^(i - 2) * (i - 1) * num)
    end
    return res
end

## example: reduce 21413 to 0
## num: step => reduced num
## 2141|4|-1: 4*2*1 + 4*0 + (4>1)*10 => 21410-1
## 214|1|0-1: 1*1*10 + 1*1*1 + (1>1)*10 => 21400-1
## 21|4|00-1: 4*1*100 + 4*2*10 + (4>1)*100 => 21000-1
## 2|1|000-1: 1*0*1000 + 1*3*100 + (1>1)*1000 => 20000-1
## |2|0000-1: 2*0*10000 + 2*4*10000 + (2>1)*10000 => 0"
"function flip_lights(n::Int, m::Int)
    n = min(n, 3)
    m == 0 && return 1
    m == 1 && return [2, 3, 4][n]
    m == 2 && return [2, 4, 7][n]
    return [2, 4, 8][n]
end"
"function min_area_free_rect(points::Vector{Vector{Int}})
    function is_right_angle(p1, p2, p3)
        return (p1[1] - p2[1]) * (p1[1] - p3[1]) + (p1[2] - p2[2]) * (p1[2] - p3[2]) == 0
    end
    point_set = Set(points)
    res, len = Inf, length(points)
    for i in 1 : len 
        for j in 1 + i : len
            for k in 1 + j : len
                flg = false
                if is_right_angle(points[i], points[j], points[k])
                    flg = true
                elseif is_right_angle(points[j], points[k], points[i])
                    flg = true
                    i, j = j, i
                elseif is_right_angle(points[k], points[i], points[j])
                    i, k = k, i
                    flg = true
                end
                if flg && (points[j] + points[k] - points[i]) in point_set
                    area = sqrt(sum((points[i] - points[j]) .^ 2) * sum((points[i] - points[k]) .^ 2))
                    (area > 0) && (res = min(res, area))
                end
            end     
        end
    end    
    (res == Inf) ? 0.0 : res
end"
"function h_index_ii(citations::Vector{Int})
    l, r = 1, length(citations) + 1
    while l < r
        mid = l + r >> 1
        if citations[end + 1 - mid] >= mid
            l = mid
        else
            r = mid - 1
        end
    end
    return r
end"
"function range_bitwise_and(m::Int, n::Int)::Int
    i = 0
    while m != n
        m >>= 1
        n >>= 1
        i += 1
    end
    return n << i
end"
"function first_unique_char(s::String)::Int
    table = Dict{Char,Bool}()
    for i in s
        table[i] = !haskey(table, i)
    end
    for (i, st) in enumerate(s)
        table[st] && return i
    end
    -1
end"
"function equations_possible(equations::Vector{String})
    disjs = DisjointSets{Char}('a':'z')
    for eq in equations
        eq[2] == '!' && continue
        union!(disjs, eq[1], eq[4])
    end
    for eq in equations
        eq[2] == '=' && continue
        in_same_set(disjs, eq[1], eq[4]) && return false
    end
    return true
end"
"function num_distinct(s::String, t::String)::Int32
    m, n = length(s) + 1, length(t) + 1
    dp = fill(0, m, n)

    dp[:, 1] .= 1

    for i = 2:m, j = 2:n
        dp[i, j] = (s[i-1] == t[j-1]) ? (dp[i-1, j-1] + dp[i-1, j]) : dp[i-1, j]
    end

    return dp[m, n]
end"
"is_balanced_binary_tree(::Nothing) = true
function is_balanced_binary_tree(root::TreeNode)::Bool
    tree_depth(::Nothing, depth::Int) = depth
    function tree_depth(tree::TreeNode, depth::Int)::Int
        ## -1 for if tree is not balanceed
        (lt = tree_depth(tree.left, depth + 1)) == -1 && return -1
        (rt = tree_depth(tree.right, depth + 1)) == -1 && return -1
        return abs(lt - rt) <= 1 ? max(lt, rt) : -1
    end
    return tree_depth(root, 0) != -1
end"
"function max_num_edges_to_remove(n, edges::Vector{Vector{Int}})
    find_root(u::Int)::Int = (father[u] == u) ? u : (father[u] = find_root(father[u]))
    issame_root(u::Int, v::Int)::Bool = find_root(u) == find_root(v)
    function merge(u::Int, v::Int)
        u_root = find_root(u)
        v_root = find_root(v)
        if u_root != v_root
            n -= 1
            father[u_root] = v_root
        end
    end
    father = collect(1:n)
    res = 0
    for edge in edges
        if edge[1] == 3
            (issame_root(edge[2], edge[3])) ? (res += 1) : (merge(edge[2], edge[3]))
        end
    end
    m = n
    father2 = father[:]
    for edge in edges
        if edge[1] == 1
            (issame_root(edge[2], edge[3])) ? (res += 1) : (merge(edge[2], edge[3]))
        end
    end
    if n != 1
        return -1
    end
    father, n = father2, m
    for edge in edges
        if edge[1] == 2
            (issame_root(edge[2], edge[3])) ? (res += 1) : (merge(edge[2], edge[3]))
        end
    end
    if n != 1
        return -1
    end
    return res
end"
"function nums_same_consec_diff(n::Int, k::Int)
    (k == 0) && return [(10 ^ n - 1) ÷ 9 * i for i in 1:9]
    function nums_same_consec_diff(n::Int, k::Int, pre::Int)
        (pre < 0 || pre > 9) && return String[]
        (n == 0) && return [""""]
        n1, n2 = pre - k, pre + k
        r1 = nums_same_consec_diff(n - 1, k, n1)       
        r2 = nums_same_consec_diff(n - 1, k, n2)
        [[string(n1) * r for r in r1]; [string(n2) * r for r in r2]]
    end
    res = Int[]
    for i in 1:9
        tmp = nums_same_consec_diff(n - 1, k, i)
        append!(res, parse(Int, string(i) * t) for t in tmp)
    end
    res
end"
"function letter_tile_possibilities(tiles::String)
    cnt = zeros(Int, 26)
    for c in tiles
        cnt[c - 'A' + 1] += 1
    end
    function dfs(cnt::Vector{Int})
        res = 0
        for i in 1:26
            cnt[i] == 0 && continue
            res += 1
            cnt[i] -= 1
            res += dfs(cnt)
            cnt[i] += 1
        end
        res
    end
    dfs(cnt)
end"
"function shopping_offers(price::Vector{Int}, special::Vector{Vector{Int}},
                         needs::Vector{Int})
    mp = Dict{NTuple{length(needs),Int},Int}()
    function rec_search(needs::Vector{Int})
        k = (needs...,)
        mp[k] = price' * needs
        for s in special
            new_need = needs - @view(s[1:(end - 1)])
            any(<(0), new_need) && continue
            mp[k] = min(mp[k], rec_search(new_need) + s[end])
        end
        return mp[k]
    end
    return rec_search(needs)
end"
"function minimum_distance(word::String)
    distance(p, q) = abs(p ÷ 6 - q ÷ 6) + abs(p % 6 - q % 6)
    len = length(word)
    dp = fill(typemax(Int) >> 1, len, 26, 26)
    dp[1, :, word[1] - 'A' + 1] .= dp[1, word[1] - 'A' + 1, :] .= 0
    for i in 2:len
        cur = word[i] - 'A' + 1
        prev = word[i - 1] - 'A' + 1
        d = distance(cur - 1, prev - 1)
        for j in 1:26
            dp[i, cur, j] = min(dp[i, cur, j], dp[i - 1, prev, j] + d)
            dp[i, j, cur] = min(dp[i, j, cur], dp[i - 1, j, prev] + d)
            if prev == j
                for k in 1:26
                    d0 = distance(k - 1, cur - 1)
                    dp[i, cur, prev] = min(dp[i, cur, prev], dp[i - 1, k, prev] + d0)
                    dp[i, prev, cur] = min(dp[i, prev, cur], dp[i - 1, prev, k] + d0)
                end
            end
        end
    end
    min(minimum(dp[len, :, word[end] - 'A' + 1]), minimum(dp[len, word[end] - 'A' + 1, :]))
end"
"function pacific_atlantic(heights::Matrix{Int})
    r, c = size(heights)
    visited = fill(false, r, c)
    res = fill(0x0, r, c)
    res[1:end, 1] .= 0x1
    res[1, 1:end] .= 0x1
    res[end, 1:end] .= 0x2
    res[1:end, end] .= 0x2
    res[1, end] = res[end, 1] = 0x3
    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]

    function dfs(x, y)
        visited[x, y] = true
        for dir in dirs
            nx, ny = x + dir[1], y + dir[2]
            (0 < nx <= r && 0 < ny <= c) || continue
            if heights[x, y] <= heights[nx, ny]
                res[nx, ny] |= res[x, y]
                !visited[nx, ny] && dfs(nx, ny)
            end
        end
    end
    for i in 1:r
        dfs(i, 1), dfs(i, c)
    end
    for j in 1:c
        dfs(1, j), dfs(r, j)
    end
    r = Set{Tuple{Int, Int}}()
    for cidx in CartesianIndices(res)
        res[cidx] == 0x3 && push!(r, cidx.I)
    end
    return r
end"
"function find132pattern(nums::Vector{Int})
    stk = Int[]
    second_great = typemin(Int)
    for num in Iterators.reverse(nums)
        second_great > num && return true
        while !isempty(stk) && stk[end] < num
            second_great = pop!(stk)
        end
        push!(stk, num)
    end
    return false
end"
"function min_steps650(n::Int)
    res, k = 0, 2
    while n != 1
        while n % k == 0
            res += k
            n ÷= k
        end
        k += 1
    end
    return res
end"
"function sample_stats(count::Vector{Int})    
    res = fill(0.0, 5)
    total = sum(count)
    half = total >> 1
    res[1] = findfirst(!=(0), count) - 1
    res[2] = findlast(!=(0), count) - 1
    res[3] = sum(x * y for (x, y) in zip(count, 0:255)) / total
    res[5] = argmax(count) - 1
    s = 0
    for i in eachindex(count)
        s += count[i]
        s < half && continue

        res[4] = i - 1
        s > half && break

        nnz = findnext(!=(0), count, i + 1)
        res[4] = iseven(total) ? (i + nnz) / 2 - 1 : nnz 
        break
    end
    res
end"
"function subarray_sum(nums::Vector{Int}, k::Int)
    mp = DefaultDict(0, 0 => 1)
    res, pre_sum = 0, 0
    for num in nums
        pre_sum += num
        res += mp[pre_sum - k]
        mp[pre_sum] += 1
    end
    res
end"
"function find_longest_word(s::String, dictionary::Vector{String})
    function is_subsequence(s::String, t::String)::Bool
        i, j = 1, 1
        lens, lent = length(s), length(t)
        while j <= lent
            if s[i] == t[j]
                i += 1
                i > lens && return true
            end
            j += 1
        end
        return false
    end
    res = """"
    for str in dictionary
        (is_subsequence(str, s) && (length(res) < length(str) || res > str)) && (res = str)
    end
    return res
end"
"function max_score(s::AbstractString)
    numofones = 0
    maxscore = score = (first(s) == '0') + (last(s) == '1')
    for i in s[2:(end - 1)]
        if i == '1'
            numofones += 1
            score -= 1
        else
            score += 1
        end
        maxscore = max(maxscore, score)
    end
    return maxscore + numofones
end"
"function furthest_building(heights::Vector{Int}, bricks::Int, ladders::Int)
    q = Int[]
    for i in 1:(length(heights) - 1)
        diff = heights[i + 1] - heights[i]
        if diff > 0
            if diff > bricks && ladders == 0
                return i - 1
            end
            if bricks >= diff
                heappush!(q, diff)
                bricks -= diff
            else
                if !isempty(q) && q[1] > diff
                    bricks += heappop!(q) - diff
                    heappush!(q, diff)
                end
                ladders -= 1
            end
        end
    end
    return length(heights) - 1
end"
"function repeated_substring_pattern(s::String)
    findnext(s, s^2, 2) != length(s) + 1 : 2 * length(s)
end"
"function single_non_duplicate(nums::Vector{Int})
    i, j = 1, length(nums)
    while i < j
        mid = (i + j) >> 1
        if isodd(mid)
            nums[mid] == nums[mid + 1] ? (i = mid + 2) : (j = mid)
        else
            nums[mid] == nums[mid + 1] ? (j = mid - 1) : (i = mid + 1)
        end
    end
    return nums[i]
end"
"function find_circle_num(is_connected::Vector{Vector{Int}})
    len = length(is_connected)
    djst = IntDisjointSets(len)
    for i in 1:len, j in (i + 1):len
        (is_connected[i][j] == 1) && (root_union!(djst, i, j))
    end
    return djst.ngroups
end"
"function is_interleave(s1::String, s2::String, s3::String)
    len1, len2, len3 = length(s1), length(s2), length(s3)
    len1 + len2 != len3 && return false
    dp = OffsetArray(fill(false, len1 + 1, len2 + 1), -1, -1)
    dp[0, 0] = true
    for i in 0:len1, j in 0:len2
        p = i + j
        i > 0 && (dp[i, j] |= dp[i - 1, j] && s1[i] == s3[p])
        j > 0 && (dp[i, j] |= dp[i, j - 1] && s2[j] == s3[p])
    end
    return dp[end, end]
end"
"function max_rotate_function(A::Vector{Int})::Int
    ## f(i+1) = f(i) + ∑(A) - A[i] * length(A)
    s = sum(A)
    n = length(A)
    cur = sum(k -> (k - 1) * A[k], 1:n)
    res = cur
    for i in n:-1:2
        cur += s - n * A[i]
        res = max(res, cur)
    end
    return res
end"
"using Dates

function alert_names(key_name::Vector{String}, key_time::Vector{String})
    res = Vector{String}()
    mp = Dict{String,Vector{Time}}()
    for (idx, name) in enumerate(key_name)
        if !haskey(mp, name)
            mp[name] = String[]
        end
        push!(mp[name], Time(key_time[idx]))
    end
    for (name, time) in mp
        sort!(time)
        for idx in 1:(length(time) - 2)
            time1h = time[idx] + Hour(1)
            if time[idx + 1] <= time1h && time[idx + 2] <= time1h
                push!(res, name)
                break
            end
        end
    end
    return sort!(res)
end

## add your code here:"
"function find_min_fibonacci_numbers(k::Int)
    fibs = [0, 1, 1]
    while fibs[end] <= k
        push!(fibs, fibs[end] + fibs[end - 1])
    end
    """"""
    If we need 2 or more fib_i's,
    we can always use fib_{i+1} and fib_{i-2} to replace them:
    2fib_i = fib_i + fib_{i-1} + fib_{i-2} = fib_{i+1} + fib_{i-2}.

    So greedy algorithm can be performed.
    """"""
    pop!(fibs)
    res = 0
    idx = length(fibs) + 1
    while k != 0
        idx -= 1
        k >= fibs[idx] || continue
        k -= fibs[idx]
        res += 1
    end
    return res
end"
"function max_sliding_window(nums::Vector{Int}, k::Int)::Vector{Int}
    q = Deque{Int}()
    len = length(nums)
    res = fill(0, len - k + 1)
    for i in 1:k-1
        num = nums[i]
        while !isempty(q) && nums[first(q)] < num
            popfirst!(q)
        end
        push!(q, i)
    end
    for i in k:len
        num = nums[i]
        while !isempty(q) && (nums[first(q)] < num || first(q) < i - k + 1)
            popfirst!(q)
        end
        while !isempty(q) && nums[last(q)] < num
            pop!(q)
        end
        push!(q, i)
        res[i - k + 1] = nums[first(q)]
    end
    res
end"
"function swap_pairs(head::ListNode)::ListNode
    pre = dummpy = ListNode()
    pre.next = head

    while !isnothing(next(pre)) && !isnothing(next(next(pre)))
        a = pre.next
        b = a.next

        ## `pre->a->b->b.next` => `pre->b->a->b.next`
        pre.next, b.next, a.next = b, a, b.next

        pre = a
    end

    return dummpy.next
end"
"function poor_pigs(buckets::Int, minutesToDie::Int, minutesToTest::Int)
    state = minutesToTest ÷ minutesToDie + 1
    return ceil(Int, log(buckets) / log(state))
end"
"function add_one_row!(root::TreeNode, val::Int, depth::Int)
    if depth == 1
        node = TreeNode(val)
        node.left = root
        node
    else
        queue = [root]
        for _ in 1:(depth - 2), _ in eachindex(queue)
            node = popfirst!(queue)
            isnothing(node.left) || push!(queue, node.left)
            isnothing(node.right) || push!(queue, node.right)
        end
        for node in queue
            left, right = node.left, node.right
            node.left = TreeNode(val)
            node.left.left = left
            node.right = TreeNode(val)
            node.right.right = right
        end
        root
    end
end"
generate_the_string(n::Int) = isodd(n) ? 'a'^n : 'a' * 'b'^(n - 1)
"min_distance583(word1::String, word2::String) = 
    length(word2) + length(word2) - 2longest_common_subsequence(word1, word2)"
"function sorted_list_to_bst(head::Union{ListNode, Nothing})::Union{TreeNode, Nothing}
    isnothing(head) && return
    isnothing(head.next) && return TreeNode(head.val)

    slow, fast = head, head.next.next
    while !isnothing(fast) && !isnothing(fast.next)
        fast = fast.next.next
        slow = slow.next
    end

    tmp = slow.next
    slow.next = nothing

    root = TreeNode(tmp.val)
    root.left = sorted_list_to_bst(head)
    root.right = sorted_list_to_bst(tmp.next)

    return root
end"
"function shortest_path_binary_matrix(mat::Matrix{Int})
    visited = fill(false, size(mat))
    q = [CartesianIndex(1, 1)]
    dist = [1]
    visited[1, 1] = true
    directions = [CartesianIndex(i, j) for i in -1:1, j in -1:1 if i != 0 || j != 0]
    res = 0
    while !visited[end, end]
        frt = popfirst!(q)
        dst = popfirst!(dist)
        for dir in directions
            next_coord = frt + dir
            next_coord ∉ CartesianIndices(mat) && continue
            visited[next_coord] && continue
            visited[next_coord] = true
            if mat[next_coord] == 0
                push!(q, next_coord)
                push!(dist, dst + 1)
                res = dst + 1
            end
        end
    end
    return res
end"
"function letter_combinations(digits::String)::Vector{String}
    isempty(digits) && return String[]
    table = Dict{Char,String}(
        '2' => ""abc"",
        '3' => ""def"",
        '4' => ""ghi"",
        '5' => ""jkl"",
        '6' => ""mno"",
        '7' => ""pqrs"",
        '8' => ""tuv"",
        '9' => ""wxyz"",
    )
    res = [""""]
    for i in digits
        res = [s1 * s2 for s1 in res for s2 in table[i]]
    end
    return res
end"
"function construct_maximum_binary_tree(nums::AbstractVector{Int})
    isempty(nums) && return nothing
    max_idx = argmax(nums)
    return TreeNode(nums[max_idx],
                    construct_maximum_binary_tree(@view(nums[1:(max_idx - 1)])),
                    construct_maximum_binary_tree(@view(nums[(max_idx + 1):end])))
end"
"function can_complete_circuit(gas::Vector{Int}, cost::Vector{Int})
    gas .-= cost
    accumulate!(+, gas, gas)
    if gas[end] < 0
        return -1
    end
    return argmin(gas) % length(gas)
end"
"function busystudent(starttime::AbstractVector, endtime::AbstractVector, query::Int)
    return count(s ≤ query ≤ e for (s, e) in zip(starttime, endtime))
end"
"function is_power_of_two(n::Int)
    return n > 0 && (n & (n - 1)) == 0
end"
"function tree_diameter(edges::Vector{Vector{Int}})
    n = length(edges)
    neighbors = Dict(i => Int[] for i in 0:n)
    for edge in edges
        u, v = edge
        push!(neighbors[u], v)
        push!(neighbors[v], u)
    end

    function depth_first(node, neighbors)
        # (current length, current node)
        longest = (0, node)

        # each tuple is (current length, current node, previous node)
        todo = [(longest..., -1)]
        while !isempty(todo)
            len, this, prev = pop!(todo)
            if len > longest[1]
                longest = (len, this)
            end

            for next in neighbors[this]
                next == prev && continue
                push!(todo, (len + 1, next, this))
            end
        end

        return longest
    end

    # we find one ""end"" of the eventual chain by doing depth first once
    # and a second time starting from the known end
    _, one_end = depth_first(0, neighbors)
    diameter, _ = depth_first(one_end, neighbors)

    return diameter
end"
"function nearest_palindromic(num::String)::String
    function remove!(data::Vector{T}, target::T) where {T}
        return deleteat!(data, findall(==(target), data))
    end
    target_num, n = parse(Int, num), length(num)
    half_num = parse(Int, num[1:cld(n, 2)])
    nums = [half_num + i for i in -1:1] ## integers
    nums = [s * reverse(s[1:(n ÷ 2)]) for s in string.(nums)] ## strings
    nums = [parse(Int, i) for i in nums] ## integers
    if n > 1 ## special cases
        push!(nums, foldl((i, j) -> 10 * i + j, fill(9, n - 1))) ## 99...9
        push!(nums, foldl((i, j) -> 10 * i + j, (1, fill(0, n - 1)..., 1))) ## 10...01
    end
    sort!(remove!(nums, target_num))
    return string(nums[argmin([abs(i - target_num) for i in nums])])
end"
"function find_smallest_set_of_vertices(n::Int, edges::Vector{Vector{Int}})::Vector{Int}
    set = Set(edge[2] for edge in edges)
    res = Int[]
    for i in 0:n-1
        (i in set) || push!(res, i)
    end
    res    
end"
"## use double pointers
function move_zeros!(nums::Vector{Int})::Nothing
    p2 = 1
    for p1 in 1:length(nums)
        if nums[p1] != 0
            nums[p1], nums[p2] = nums[p2], nums[p1]
            p2 += 1
        end
    end
    return nothing
end"
"function reorganize_string(S::String)
    char_arr = codeunits(S)
    ascii_a, len = Int('a'), length(S)
    mp = fill(0, 26)
    for ch in char_arr
        mp[ch - ascii_a + 1] += 1
    end
    max_freq = argmax(mp)
    if mp[max_freq] > (len + 1) ÷ 2
        return """"
    end
    res = fill('a', len)
    idx = 1
    for i in 1:mp[max_freq]
        res[idx] = Char(max_freq + ascii_a - 1)
        idx += 2
    end
    mp[max_freq] = 0
    for i in 1:26
        for j in 1:mp[i]
            (idx > len) && (idx = 2)
            res[idx] = Char(i + ascii_a - 1)
            idx += 2
        end
    end
    ## println(res)
    return String(res)
end"
"function reverse_bit(n::UInt32)::UInt32
    ret, power = 0, 31
    while n != 0
        ret += (n & 1) << power
        power -= 1
        n = n >> 1
    end

    return ret
end"
"## use build-in function
plus_one(nums::Vector{Int}) = reverse!(digits(foldl((i, j) -> 10 * i + j, nums) + 1))
## method 2
function digits_plus_one(nums::Vector{Int})::Vector{Int}
    pos = findlast(!=(9), nums)
    isnothing(pos) && return append!([1], zeros(Int, length(nums)))
    return cat(
        @view(nums[1:(pos - 1)]), nums[pos] + 1, zeros(Int, length(nums) - pos); dims=1
    )
end"
"function is_ipv4(text::String)
    data = split(text, '.')
    length(data) != 4 && return false
    any(length(x) > 1 && first(x) == '0' for x in data) && return false
    try
        all(0 <= parse(Int, x) <= 255 for x in data)
    catch
        return false
    end
end

function is_ipv6(text::String)
    data = split(text, ':')
    length(data) != 8 && return false
    any(length(x) > 4 for x in data) && return false
    return all(all.(isxdigit, data))
end

function valid_ip_address(query_ip::String)::String
    is_ipv4(query_ip) && return ""IPv4""
    is_ipv6(query_ip) && return ""IPv6""
    return ""Neither""
end"
"width_of_binary_tree(root::Nothing) = 0

function width_of_binary_tree(root::TreeNode{Int})::Int
    q1 = Tuple{TreeNode{Int}, Int}[]
    q2 = copy(q1)
    push!(q1, (root, 1))
    res = 1
    while !isempty(q1)
        res = max(res, q1[end][2] - q1[1][2] + 1)     
        for (nd, idx) in q1
            !isnothing(nd.left) && push!(q2, (nd.left, idx << 1))
            !isnothing(nd.right) && push!(q2, (nd.right, (idx << 1) + 1))
        end
        q1, q2 = q2, q1
        empty!(q2)
    end
    return res
end"
"function longest_common_prefix(strs::Vector{String})::String
    s1, s2 = minimum(strs), maximum(strs)
    pos = findfirst(i -> s1[i] != s2[i], 1:length(s1))
    return isnothing(pos) ? s1 : s1[1:(pos - 1)]
end"
"function largest_perimeter(A::Vector{Int})
    sort!(A; rev=true)
    for i in 1:(length(A) - 2)
        (A[i] < A[i + 1] + A[i + 2]) && return A[i] + A[i + 1] + A[i + 2]
    end
    return 0
end"
"function del_nodes1110(node::TreeNode{Int}, to_delete::Vector{Int})
    to_deletes = Set(to_delete)
    res = TreeNode{Int}[]
    queue = [(node, true)]

    while !isempty(queue)
        root, flg = popfirst!(queue)
        if root.val ∈ to_deletes
            !isnothing(root.left) && push!(queue, (root.left, true))
            !isnothing(root.right) && push!(queue, (root.right, true))
            continue
        end
        for child in (:left, :right)
            isnothing(getproperty(root, child)) && continue
            if getproperty(root, child).val ∈ to_deletes
                !isnothing(getproperty(root, child).left) &&
                    push!(queue, (getproperty(root, child).left, true))
                !isnothing(getproperty(root, child).right) &&
                    push!(queue, (getproperty(root, child).right, true))
                setproperty!(root, child, nothing)
            else
                push!(queue, (getproperty(root, child), false))
            end
        end
        flg && push!(res, root)
    end
    return res
end"
"function predict_party_victory(senate::String)
    len = length(senate)
    radiant, dire = Queue{Int}(), Queue{Int}()
    for (idx, ch) in enumerate(senate)
        (ch == 'R') ? enqueue!(radiant, idx) : enqueue!(dire, idx)
    end
    while !isempty(radiant) && !isempty(dire)
        r_front, d_fromt = dequeue!(radiant), dequeue!(dire)
        (r_front < d_fromt) ? enqueue!(radiant, r_front + len) : enqueue!(dire, d_fromt + len)

    end
    return isempty(dire) ? ""Radiant"" : ""Dire""
end"
"function corp_flight_bookings(bookings::Vector{Vector{Int}}, n::Int)
    res = fill(0, n + 1)
    for b in bookings
        res[b[1]] += b[3]
        res[b[2] + 1] -= b[3]
    end
    cumsum!(res, res)
    @view(res[1:n])
end"
"function smallest_good_base(n::Int)
    for m in 62:-1:2
        k = floor(Int, n^(1 / m))
        k ≤ 1 && continue
        s = (Int128(k)^(m + 1) - 1) ÷ (k - 1)
        (s == n) && return k
    end
    n - 1
end"
"struct LRUCache
    cap::Int
    data::OrderedDict{Int, Int}
    LRUCache(cap::Int) = new(cap, OrderedDict{Int, Int}())
end

function Base.getindex(cache::LRUCache, key) 
    key ∉ keys(cache.data) && return -1
    res = cache.data[key]
    delete!(cache.data, key)
    cache.data[key] = res
    return res
end

function Base.setindex!(cache::LRUCache, val, key)
    if key in keys(cache.data)
        delete!(cache.data, key)
        cache.data[key] = val
    else
        length(cache.data) == cache.cap && delete!(cache.data, first(cache.data|> keys))
        cache.data[key] = val
    end
end"
"function maximum_swap670(nums::Int)
    dgs = digits(nums)
    for i in 1:length(dgs)
        cur = @view(dgs[i:end])
        max_idx = argmax(cur)
        max_idx == lastindex(cur) && continue
        dgs[end], dgs[max_idx] = dgs[max_idx], dgs[end]
        break
    end
    return [10 .^ (0:length(dgs)-1);]' * dgs
end"
"function best_rotation(nums::Vector{Int})::Int
    n = length(nums)
    diffs = fill(0, n)
    for (i, num) in enumerate(nums)
        diffs[mod(i - num - 1, n) + 1] -= 1
        diffs[i] += 1
    end
    ans = maxscore = score = 0
    for (i, num) in enumerate(@view(diffs[1:(end - 1)]))
        score += num
        if score > maxscore
            maxscore, ans = score, i
        end
    end
    return ans
end"
"function valid_square(ps::Vector{Vector{Int}})
    sort!(ps)
    ps[1] + ps[4] != ps[2] + ps[3] && return false
    sum((ps[1] .- ps[2]) .^ 2) != sum((ps[1] .- ps[3]) .^ 2) && return false
    return true
end"
"function judge_square_sum(n::Int)
    upper = isqrt(n)
    i = 0
    while i <= upper
        ss = i ^ 2 + upper ^ 2
        ss == n && return true
        ss > n ? (upper -= 1) : (i += 1)
    end
    return false
end"
"max_uncrossed_lines(nums1::Vector{Int}, nums2::Vector{Int}) = 
    longest_common_subsequence(nums1, nums2)"
"using DataStructures
function is_anagram(s::String, t::String)::Bool
    length(s) != length(t) && return false
    count_s, count_t = DefaultDict{Char,Int}(0), DefaultDict{Char,Int}(0)
    for i in eachindex(s)
        count_s[s[i]] += 1
        count_t[t[i]] += 1
    end
    return all(count_s[c] == count_t[c] for c in 'a':'z')
end"
"function single_number(nums::Vector{Int})::Int
    a, b = 0, 0
    for num in nums
        b = (b ⊻ num) & ~a
        a = (a ⊻ num) & ~b
    end
    return b
end"
"function length_of_LIS(nums::Vector{Int})
    f = [first(nums)]
    for num in @view(nums[2:end])
        if num > f[end] 
            push!(f, num)
        else
            f[searchsortedfirst(f, num)] = num
        end
    end
    length(f)
end"
"function min_operations_1198(logs::Vector{String})
    res = 0
    for lg in logs
        if lg == ""../""
            res = max(0, res - 1)
        elseif lg != ""./""
            res += 1
        end
    end
    return res
end"
"Base.@kwdef struct StockSpanner
    history::Vector{Pair{Int,Int}} = []
end

function next!(s::StockSpanner, price::Int)
    span = 1
    while !isempty(s.history) && s.history[end][1] <= price
        span += s.history[end][2]
        pop!(s.history)
    end
    push!(s.history, price => span)
    return span
end"
"function coin_change(coins::Vector{Int}, amount::Int)
    res = OffsetArray(fill(amount + 1, 1 + amount), -1)
    res[0] = 0
    @inbounds for coin in coins, i in 0:(amount - coin)
        res[i + coin] = min(res[i + coin], res[i] + 1)
    end
    return res[end] == amount + 1 ? -1 : res[end]
end"
"function max_width_of_vertical_area(points::Vector{Vector{Int}})
    sort!(points)
    return maximum(points[i][1] - points[i - 1][1] for i in 2 : length(points))
end"
"## binary search + merge sort
function squares_of_a_sorted_array(nums::Vector{Int})::Vector{Int}
    n = length(nums)
    ## binary search
    left, right = 1, n
    while left <= right
        mid = (right + left) >> 1
        if nums[mid] < 0
            left = mid + 1
        else
            right = mid - 1
        end
    end
    ## merge sort
    i, j, res = right, left, Int[]
    while i >= 1 && j <= n
        if nums[i]^2 < nums[j]^2
            push!(res, nums[i]^2)
            i -= 1
        else
            push!(res, nums[j]^2)
            j += 1
        end
    end
    return vcat(res, (i == 0) ? nums[j:end] .^ 2 : nums[i:-1:1] .^ 2)
end"
"function find_substring_in_wrapround_string(p::String)
    dp = fill(0, 26)
    k = 0
    iscont(prev, cur) = cur == (prev == 'z' ? 'a' : prev + 1)
    for i in 1:length(p)
        k = (i > 1 && iscont(p[i - 1], p[i])) ? k + 1 : 1
        dp[p[i] - 'a' + 1] = dp[p[i] - 'a' + 1] > k ? dp[p[i] - 'a' + 1] : k
    end
    return sum(dp)
end"
"function is_rational_equal(s::String, t::String)
    function to_rational(s::String)::Rational
        pos1, pos2 = findfirst('.', s), findfirst('(', s)
        (pos1 === nothing) && return parse(Int, s)
        (pos1 == length(s)) && return parse(Int, s[1:end-1])
        pos2 === nothing && return parse(Int, s[1:pos1-1]) + parse(Int, s[pos1 + 1:end]) // 10 ^ (length(s) - pos1) 
        pos3 = findlast(')', s)
        int_part = parse(Int, s[1:pos1-1]) |> Rational
        nr_part = pos1 == pos2 - 1 ? 0 : parse(Int, s[pos1+1:pos2-1]) // 10 ^ (pos2 - pos1 - 1)
        rp_part = parse(Int, s[pos2+1:pos3-1]) // (10 ^ (pos3 - pos2 - 1) - 1) // 10 ^ (pos2 - pos1 - 1)
        int_part + nr_part + rp_part
    end
    to_rational(s) == to_rational(t)
end

is_rational_equal(""0.9(9)"", ""1."")"
"function is_valid_BST(root)
    isnothing(root) && return true
    arr = Int[]
    function pre_tra(root::TreeNode{Int})
        pre_tra(root.left)
        push!(arr, root.val)
        return pre_tra(root.right)
    end
    pre_tra(::Nothing) = nothing
    pre_tra(root)
    return issorted(arr; lt=!isless, rev=true)
end"
"function distinct_subseq2(s::String)
    arr = zeros(Int, 26)
    for c in codeunits(s)
        arr[c - UInt8('a' - 1)] = (sum(arr) + 1) % 1_000_000_007
    end
    return sum(arr) % 1_000_000_007
end"
"function kth_smallest_in_BST(root, k::Int)::Int
    isnothing(root) && return true
    arr = Int[]
    function pre_tra(root::TreeNode{Int})
        pre_tra(root.left)
        push!(arr, root.val)
        pre_tra(root.right)
    end
    pre_tra(::Nothing) = nothing
    pre_tra(root)
    arr[k]
end"
"function find_duplicates_442(nums::Vector{Int})
    res = Int[]
    for num in nums
        absn = abs(num)
        nums[absn] < 0 ? push!(res, absn) : (nums[absn] = -nums[absn])
    end
    return res
end"
"function buddy_strings(A::String, B::String)::Bool
    if length(A) == length(B)
        different_pairs = Pair{Char,Char}[]
        for (a, b) in zip(A, B)
            if a != b
                push!(different_pairs, a => b)
            end
        end
        if length(different_pairs) == 0
            ## check if A contains at least 2 duplicate letters
            length(Set(A)) < length(A)
        elseif length(different_pairs) == 2
            ((x, y), (z, w)) = different_pairs
            x == w && y == z
        else
            false
        end
    else
        false
    end
end"
"function sum_odd_length_subarrays(arr::Vector{Int})::Int
    res = 0
    len = length(arr)
    for i in 1:len
        l, r = i - 1, len - i
        lodd, rodd = (l + 1) ÷ 2, (r + 1) ÷ 2
        leven, reven = l ÷ 2 + 1, r ÷ 2 + 1
        res += arr[i] * (lodd * rodd + leven * reven) 
    end
    res
end"
"function path_in_zig_zag_tree(n::Int)
    res = Int[]
    layer = floor(Int, log2(n)) + 1
    while layer != 0
        push!(res, n)
        b = (1 << layer) + (1 << (layer - 1)) - 1
        iseven(layer) && (n = b - n)
        n >>= 1
        layer -= 1
        iseven(layer) && (n = (b >> 1) - n)
    end
    reverse!(res)
    return res
end"
"struct MyHashMap
    buckets::Int
    table::Vector{Vector{T}} where {T}
    MyHashMap() = new(1009, [Tuple{Int,Int}[] for _ = 1:1009])
end

hash_706(hash_map::MyHashMap, key::Int) = mod1(key, hash_map.buckets)

function put_706!(hash_map::MyHashMap, key::Int, value::Int)
    hash_key = hash_706(hash_map, key)

    if !isempty(hash_map.table[hash_key])
        for (i, item) in enumerate(hash_map.table[hash_key])
            if item[1] == key
                hash_map.table[hash_key][i] = (key, value)
                return
            end
        end
    end

    push!(hash_map.table[hash_key], (key, value))
    return
end

function remove_706!(hash_map::MyHashMap, key)
    hash_key = hash_706(hash_map, key)

    if !isempty(hash_map.table[hash_key])
        for (i, item) in enumerate(hash_map.table[hash_key])
            if item[1] == key
                deleteat!(hash_map.table[hash_key], i)
                return
            end
        end
    end
end

function get_706(hash_map::MyHashMap, key)
    hash_key = hash_706(hash_map, key)

    for item in hash_map.table[hash_key]
        !isempty(item) && item[1] == key && return item[2]
    end

    return -1
end"
"function min_startvalue(nums::Vector{Int})
    total = mintotal = 0
    for num in nums
        total += num
        mintotal = min(mintotal, total)
    end
    return 1 - min(0, mintotal)
end"
"function find_judge(N::Int, trust::Vector{Vector{Int}})
    cnt = fill(0, N)
    for t in trust
        cnt[t[1]] -= 1
        cnt[t[2]] += 1
    end
    res = findfirst(==(N - 1), cnt)
    return isnothing(res) ? -1 : res
end"
"function check_subarray_sum(nums::Vector{Int}, k::Int)
    pushfirst!(nums, 0)
    cumsum!(nums, nums)
    nums .%= k
    st = Set{Int}()
    len = length(nums)
    for i in 3:len
        nums[i] ∈ st && return true
        push!(st, nums[i - 1])
    end
    return false
end"
"function k_inverse_pairs(n::Int, k::Int)
    dp = OffsetArray(fill(0, n + 1, k + 1), -1, -1)
    dp[:, 0] .= 1
    m = 1000000007
    @inbounds for i in 1:n, j in 1:min(k, i * (i - 1) ÷ 2)
        val = dp[i - 1, j] - ((j - i) >= 0 ? dp[i - 1, j - i] : 0)
        dp[i, j] = (dp[i, j - 1] + val) % m
    end
    return (dp[n, k] + m) % m
end"
"function partition_disjoint(nums::Vector{Int})
    n, pos = length(nums), 0
    maxn = leftm = nums[1]
    for i in 2:n
        maxn = max(maxn, nums[i])
        if nums[i] < leftm
            leftm = maxn
            pos = i
        end
    end
    return pos
end"
"function sum_subarray_mins(arr::Vector{Int})
    csum, res, md = 0, 0, Int(1e9) + 7
    stk = Int[]
    for i in eachindex(arr)
        while !isempty(stk) && arr[stk[end]] >= arr[i]
            tp = pop!(stk)
            ntop = isempty(stk) ? 0 : stk[end]
            csum += (arr[i] - arr[tp]) * (tp - ntop);
        end
        csum += arr[i]
        push!(stk, i)
        res += csum
    end
    return res % md
end"
"## using @view macro
function build_tree_105(preorder::AbstractArray, inorder::AbstractArray)::TreeNode
    root = TreeNode(first(preorder))
    pos = findfirst(==(root.val), inorder)
    pos != 1 &&
        (root.left = build_tree_105(@view(preorder[2:pos]), @view(inorder[1:(pos - 1)])))
    pos != length(preorder) && (
        root.right = build_tree_105(
            @view(preorder[(pos + 1):end]), @view(inorder[(pos + 1):end])
        )
    )
    return root
end"
"function num_magic_squares_inside(grid::Matrix{Int})::Int
    r = [15, 15, 15]
    function is_magic_square(grid::AbstractMatrix{Int})
        sum(grid; dims=1) != reshape(r, 1, 3) && return false
        sum(grid; dims=2) != reshape(r, 3, 1) && return false
        sum(grid[i, i] for i in 1:3) == sum(grid[i, 4 - i] for i in 1:3) == 15 && return true
        return false
    end
    res = 0
    for j in 1:size(grid,2)-2, i in 1:size(grid,1)-2
        sub_mat = @view(grid[CartesianIndex(i, j):CartesianIndex(i+2, j+2)])
        all(x -> x in sub_mat, 1:9) && is_magic_square(sub_mat) && (res += 1)
    end
    return res
end"
"function lowest_common_ancestor_236(
    root::TreeNode{Int}, p::TreeNode{Int}, q::TreeNode{Int}
)::TreeNode{Int}
    function dfs(node::Union{TreeNode{Int},Nothing})
        (isnothing(node) || node == p || node == q) && return node
        left, right = dfs(node.left), dfs(node.right)
        isnothing(left) && isnothing(right) && return nothing
        !isnothing(left) && !isnothing(right) && return node
        return !isnothing(left) ? left : right
    end
    return dfs(root)
end"
"function contains_nearby_duplicate(nums::Vector{Int}, k::Int)::Bool
    pos = Dict{Int,Int}()
    for (i, num) in enumerate(nums)
        haskey(pos, num) && i - pos[num] <= k && return true
        pos[num] = i
    end
    return false
end"
"function find_min_difference(time_points::Vector{String})
    ttp = Tuple{Int, Int}[]    
    for t in time_points
        st = split(t, ':')
        push!(ttp, (parse(Int, st[1]), parse(Int, st[2])))
    end
    sort!(ttp)
    push!(ttp, (ttp[1][1] + 24, ttp[1][2]))
    return minimum((ttp[i][1] - ttp[i-1][1]) * 60 + (ttp[i][2] - ttp[i-1][2]) for i in 2:length(ttp))
end"
"function find_max_form(strs::Vector{String}, m::Int, n::Int)
    dp = OffsetArray(fill(0, m + 1, n + 1), -1, -1)
    for str in strs
        o = count(==('1'), str)
        z = length(str) - o
        for j in m:-1:z, k in n:-1:o
            dp[j, k] = max(dp[j, k], dp[j - z, k - o] + 1)            
        end
    end
    return dp[end]
end"
"function height_checker(heights::Vector{Int})
    sorted = sort(heights)
    return count(i -> heights[i] != sorted[i], 1:length(heights))
end"
"function longest_common_substring(itr1, itr2)
    m, n = length(itr1) + 1, length(itr2) + 1
    dp = fill(0, m, n)
    for i in 2: m, j in 2: n
        (itr1[i - 1] == itr2[j - 1]) && (dp[i, j] = dp[i - 1, j - 1] + 1)
    end
    return maximum(dp)
end

find_length718(nums1::Vector{Int}, nums2::Vector{Int}) = longest_common_substring(nums1, nums2)"
"function max_width_ramp(A::Vector{Int})
    res = 0
    stk = [1]
    for i in 2:length(A)
        (A[i] < A[stk[end]]) && (push!(stk, i))
    end
    for i in length(A):-1:2
        idx = i
        while !isempty(stk) && A[stk[end]] <= A[i]
            idx = pop!(stk)
        end
        res = max(i - idx, res)
    end
    return res
end"
"function find_restaurant(list1::Vector{String}, list2::Vector{String})::Vector{String}
    dic = Dict(st => (i - 1) for (i, st) in enumerate(list1))
    cost, res = typemax(1), String[]
    for (i, s) in enumerate(list2)
        !haskey(dic, s) && continue
        newcost = i - 1 + dic[s]
        if newcost < cost
            cost, res = newcost, [s]
        elseif newcost == cost
            push!(res, s)
        end
    end
    return res
end"
"function next_larger_nodes(head::ListNode{Int})
    head = reverse_list(head)
    stk = Int[]
    res = Int[]
    while !isnothing(head)
        while !isempty(stk) && stk[end] <= val(head)
            pop!(stk)
        end
        pushfirst!(res, isempty(stk) ? 0 : stk[end])
        push!(stk, val(head))
        head = next(head)
    end
    return res
end"
"function calculate_minimum_hp(dungeon::Vector{Vector{Int}})
    m, n = length(dungeon), length(dungeon[1])
    dp = fill(typemax(Int) , m + 1, n + 1)
    dp[m+1, n] = dp[m, n+1] = 1
    for j in n:-1:1
        for i in m:-1:1
            dp[i, j] = max(min(dp[i+1, j], dp[i, j+1]) - dungeon[i][j], 1)
        end
    end 
    dp[1, 1]
end"
"function ship_within_days(weights::Vector{Int}, D::Int)
    lo, hi = maximum(weights), sum(weights)
    while lo < hi
        mid = (lo + hi) ÷ 2
        cnt = 1
        tt = 0
        for w in weights
            tt += w
            if tt > mid
                cnt += 1
                tt = w
            end
        end
        cnt > D ? (lo = mid + 1) : (hi = mid)
    end
    return lo
end"
"function search_bst(root::TreeNode, val::Int)::Union{TreeNode,Nothing}
    while !isnothing(root)
        root.val == val && return root
        root = (root.val > val) ? root.left : root.right
    end
end"
"function relative_sort_array(arr1::Vector{Int}, arr2::Vector{Int})
    res = Vector{Int}(undef, length(arr1))
    idx = length(res)
    dc = Dict{Int,Int}((k => 0) for k in arr2)
    for i in arr1
        if haskey(dc, i)
            dc[i] += 1
        else
            res[idx] = i
            idx -= 1
        end
    end
    sort!(@view(res[(idx + 1):end]))
    idx = 1
    for item in arr2
        res[idx:(idx + dc[item] - 1)] .= item
        idx += dc[item]
    end
    return res
end"
"function max_score_sightseeing_pair(A::Vector{Int})
    res, mx = 0, A[1] + 0
    for j in 2:length(A)
        res = max(res, A[j] - j + 1 + mx)
        mx = max(mx, A[j] + j - 1)
    end
    res
end"
"function find_min_153(nums::Vector{Int})
    left, right = 1, length(nums)
    while left < right
        mid = (left + right) ÷ 2
        (nums[mid] < nums[right]) ? (right = mid) : (left = mid + 1)
    end
    nums[left]
end"
"function modify_string(s::String)
    char_vec = collect(s)
    for i in 1:length(char_vec)
        if char_vec[i] == '?'
            char_vec[i] = 'a'
            (i > 1 && char_vec[i - 1] == 'a') && (char_vec[i] += 1)
            (i < length(char_vec) && char_vec[i + 1] == char_vec[i]) && (char_vec[i] += 1) 
            (i > 1 && char_vec[i - 1] == char_vec[i]) && (char_vec[i] += 1)
        end
    end
    return join(char_vec)
end"
"function remove_duplicates1!(nums::Vector{Int})::Int
    j = 2
    for i in 2: length(nums)
        if nums[i] != nums[j - 1]
            nums[j] = nums[i]
            j += 1
        end
    end

    return j - 1
end"
"function num_subarray_productLess_than_k(nums::Vector{Int}, k::Int)
    k <= 1 && return 0
    res, left = 0, 1
    p = 1
    for (right, val) in enumerate(nums)
        p *= val
        while p >= k
            p ÷= nums[left]
            left += 1
        end
        res += right - left + 1
    end
    return res
end"
"function min_path_sum!(grid::Vector{Vector{Int}})::Int
    m, n = length(grid), length(grid[1])
    for i in 2:n
        grid[1][i] += grid[1][i - 1]
    end
    for i in 2:m
        grid[i][1] += grid[i - 1][1]
    end
    for i in 2:m
        for j in 2:n
            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])
        end
    end
    return grid[end][end]
end
min_path_sum(grid::Vector{Vector{Int}}) = min_path_sum!(copy(grid))"
"function two_sum(nums::Vector{Int}, target::Int)::Union{Nothing,Tuple{Int,Int}}
    seen = Dict{Int,Int}()
    for (i, n) in enumerate(nums)
        m = target - n
        if haskey(seen, m)
            return seen[m], i
        else
            seen[n] = i
        end
    end
end"
"function trap(height::Vector{Int})::Int32
    left, right = 1, length(height)
    left_max, right_max = 0, 0
    res = 0

    while left <= right
        if height[left] < height[right]
            if (span = left_max - height[left]) > 0
                res += span
            else
                left_max = height[left]
            end

            left += 1
        else
            if (span = right_max - height[right]) > 0
                res += span
            else
                right_max = height[right]
            end

            right -= 1
        end
    end

    return res
end"
"function wiggle_sort!(nums::Vector{Int})
    len = length(nums)
    md = len ÷ 2
    partialsort!(nums, md)
    nums[1], nums[md] = nums[md], nums[1]
    i, j = 2, len
    iseven(len) && (j -= 1)
    while i <= j
        nums[i], nums[j] = nums[j], nums[i]
        i += 2
        j -= 2
    end
    return nums
end"
"function actual_email(email)
    name, domain = split(email, '@')
    name = first(split(replace(name, ""."" => """"), ""+""))
    return name * ""@"" * domain
end

function num_unique_emails(emails::Vector{String})
    return length(unique(actual_email(email) for email in emails))
end"
"function is_subsequence(s::String, t::String)::Bool
    if length(s) == 0
        true
    else
        i, j = 1, 1
        while j <= length(t)
            if s[i] == t[j]
                i += 1
                if i > length(s)
                    return true
                end
            end
            j += 1
        end
        false
    end
end"
"function pancake_sort(arr::Vector{Int})
    len = length(arr)
    res = Int[]
    for i in len:-1:1
        v = @view(arr[1:i])
        agm = argmax(v)
        if i != agm
            append!(res, (agm, i))
            pancake_sort!(arr, (agm, i))
        end
    end
    return res
end
function pancake_sort!(arr::Vector{Int}, ops)
    for op in ops
        reverse!(@view(arr[1:op]))
    end
    return arr
end"
"function xor_queries(arr::Vector{Int}, queries::Vector{Vector{Int}})
    pushfirst!(arr, 0)
    off_arr = OffsetArray(arr, -1)
    for i in 1:(length(arr) - 1)
        @inbounds off_arr[i] = off_arr[i] ⊻ off_arr[i - 1]
    end
    res = fill(0, length(queries))
    for (idx, q) in enumerate(queries)
        @inbounds res[idx] = off_arr[q[2] + 1] ⊻ off_arr[q[1]]
    end
    return res
end"
"function can_adj(u, v) 
    sq = isqrt(u + v)
    return sq * sq == u + v
end

function num_squareful_perms(nums::Vector{Int})
    ctr = counter(nums)
    adj_set = Set{Tuple{Int, Int}}()
    for i1 in 1:length(nums), i2 in i1:length(nums) 
        n1, n2 = nums[i1], nums[i2]
        if can_adj(n1, n2) 
            push!(adj_set, (n1, n2))
            push!(adj_set, (n2, n1))
        end
    end
    function gen_perms(ctr, lst = nothing)
        sum(ctr) == 0 && return 1
        res = 0
        for k in keys(ctr)
            (ctr[k] == 0 || !isnothing(lst) && (lst, k) ∉ adj_set) && continue
            ctr[k] -= 1
            res += gen_perms(ctr, k)
            ctr[k] += 1
        end
        res
    end
    gen_perms(ctr)
end"
"function powerful_integers(x::Int, y::Int, bound::Int)
    res = Set{Int}()
    i = 1
    while i < bound
        j = 1
        while i + j ≤ bound
            push!(res, i + j)
            j *= y
            (y == 1) && break
        end
        i *= x
        (x == 1) && break
    end
    res
end"
"function max_freq(s::String, max_letters::Int, min_size::Int, max_size::Int)::Int
    counts = Dict{SubString,Int}()

    for i in 1:(length(s) - min_size + 1),
        j in (i + min_size - 1):min(length(s), i + max_size + 1)

        ŝ = SubString(s, i, j)
        if length(Set(ŝ)) <= max_letters
            counts[ŝ] = get(counts, ŝ, 0) + 1
        end
    end
    return length(counts) > 0 ? maximum(values(counts)) : 0
end"
"function nth_ugly_number(n::Int)
    dp = Vector{Int}(undef, n)
    p2 = p3 = p5 = dp[1] = 1
    for i in 2:n
        nums = dp[p2] * 2, dp[p3] * 3, dp[p5] * 5
        dp[i] = minimum(nums)
        p2 += dp[i] == nums[1]
        p3 += dp[i] == nums[2]
        p5 += dp[i] == nums[3]        
    end
    return dp[n]
end"
"function frequency_sort(nums::Vector{Int})
    freq = counter(nums)
    sort!(nums, by = x -> (freq[x], -x))
end"
"function surface_area(grid::Vector{Vector{Int}})
    res = 2 * sum(sum(1 for i in row if i != 0) for row in grid)
    res += sum(row[1] + row[end] + sum(abs, diff(row)) for row in grid)
    return res += sum(grid[1][i] +
                      grid[end][i] +
                      ((length(grid) > 1) ?
                       (sum(abs(grid[row][i] - grid[row - 1][i]) for row in 2:length(grid))) :
                       0) for i in 1:length(grid[1]))
end
function surface_area(grid::Matrix{Int})
    res = 2 * sum(sum(1 for i in row if i != 0) for row in grid)
    res += sum(row[1] + row[end] + sum(abs, diff(row)) for row in eachrow(grid))
    res += sum(col[1] + col[end] + sum(abs, diff(col)) for col in eachcol(grid))
    res
end"
"function bitwise_complement(N::Int)
    res = 0
    for i in 0:31
        if N > 0
            res += ((1 - (N & 1)) << i)
            N >>= 1
        else
            return res
        end
    end
end"
"function is_monotonic(A::Vector{Int})
    return issorted(A) || issorted(A; rev = true)
end"
"function num_pairs_divisible_by60(time::Vector{Int})
    res = 0
    dct = fill(0, 60)
    for t in time
        (t % 60 == 0) ? (dct[60] += 1) : (dct[t % 60] += 1)
    end
    for i in 1:29
        res += dct[i] * dct[60 - i]
    end
    res += sum(1:(dct[30] - 1)) + sum(1:(dct[60] - 1))
    return res
end"
"function max_sum_after_partitioning(arr::Vector{Int}, k::Int)
    n = length(arr)
    dp = OffsetArray(zeros(Int, n + 1), -1)
    for i in 1:n
        maxn = arr[i]
        dp[i] = maxn + dp[i - 1]
        for j in (i - 1):-1:max(1, i - k + 1)
            maxn = max(maxn, arr[j])
            dp[i] = max(dp[i], (i - j + 1) * maxn + dp[j - 1])
        end
    end
    return dp[n]
end"
"function longest_substring_395(s::String, k::Int)
    function dfs(l::Int, r::Int)
        l > r && return 0
        cnt = counter(SubString(s, l, r))
        split_set = Int[]
        for i in l:r
            (cnt[s[i]] < k) && push!(split_set, i)
        end
        isempty(split_set) && return r - l + 1
        lft, res = l, 0
        for rt in split_set 
            res = max(res, dfs(lft, rt - 1))
            lft = rt + 1
        end
        res
    end
    dfs(1, length(s))
end"
"Base.@kwdef mutable struct PrefixNode
    isend::Bool = false
    children = Dict{Char,PrefixNode}()
end

function insert_node!(node::PrefixNode, word::String)::Nothing
    for c in word
        children = node.children
        haskey(children, c) || (children[c] = PrefixNode())
        node = children[c]
    end
    node.isend = true
    return nothing
end

function search_prefix_node(node::PrefixNode, prefix::String)::Union{Nothing,PrefixNode}
    for c in prefix
        children = node.children
        haskey(children, c) || return nothing
        node = children[c]
    end
    return node
end

function search_word(node::PrefixNode, word::String)::Bool
    node = search_prefix_node(node, word)
    return !isnothing(node) && node.isend
end

starts_with(node::PrefixNode, prefix::String) = !isnothing(search_prefix_node(node, prefix))"
"function merge_two_lists(
    list1::Union{ListNode,Nothing}, list2::Union{ListNode,Nothing}
)::Union{ListNode,Nothing}
    isnothing(list1) && isnothing(list2) && return nothing
    node = fake_head = ListNode()
    while !isnothing(list1) && !isnothing(list2)
        node.next = ListNode()
        node = next(node)
        if val(list1) < val(list2)
            node.val = list1.val
            list1 = next(list1)
        else
            node.val = list2.val
            list2 = next(list2)
        end
    end
    l = isnothing(list2) ? list1 : list2
    while !isnothing(l)
        node.next = ListNode()
        node = next(node)
        node.val = l.val
        l = next(l)
    end
    return next(fake_head)
end"
"inorder_traversal(::Nothing) = Int[]
function inorder_traversal(root::TreeNode)::Vector{Int}
    res, stack = Int[], []
    while !isempty(stack) || !isnothing(root)
        while !isnothing(root)
            push!(stack, root)
            root = root.left
        end
        root = pop!(stack)
        push!(res, root.val) ## inorder search
        root = root.right
    end
    return res
end

##### code template for inorder traversal and preorder traversal #####
## traversal(::Nothing) = Int[]
## function traversal(root::TreeNode)::Vector{Int}
##     res, stack = Int[], []
##     while !isempty(stack) || !isnothing(root)
##         while !isnothing(root)
##             push!(stack, root)
##             ## preorder traversal: put codes here
##             root = root.left
##         end
##         root = pop!(stack) 
##         ## inorder traversal: put codes here
##         root = root.right
##     end
##     res
## end"
"function count_numbers_with_unique_digits(n::Int)
    n > 10 && return count_numbers_with_unique_digits(10)
    n == 0 && return 1
    return 9 * binomial(9, n - 1) * factorial(n - 1) +
           count_numbers_with_unique_digits(n - 1)
end"
"function find_maximized_capital(k::Int, w::Int, profits::Vector{Int}, capital::Vector{Int})
    arr = @view(collect(zip(capital, profits))[:])
    sort!(arr)
    hp = Int[]
    for _ in 1:k
        idx = searchsortedlast(arr, (w + 1, -1))
        for item in @view(arr[1:idx])
            heappush!(hp, -item[2])
        end
        arr = @view(arr[idx+1:end])
        w -= isempty(hp) ? 0 : hp[1]
    end
    w
end"
"function large_group_positions(s::String)::Vector{Vector{Int}}
    ch = s[1]
    bg = 1
    res = Vector{Int}[]
    for i in 2:length(s)
        if s[i] != ch
            if i - bg > 2
                push!(res, [bg - 1, i - 2]) #1-index to 0-index 
            end
            ch = s[i]
            bg = i 
        end
    end
    res
end"
"function num_dup_digits_at_most_n(N::Int)
    ori = N
    b = 9
    while 10^b > N
        b -= 1
    end
    res = sum(binomial(9, i) * factorial(i) * 9 for i in 0:(b - 1))
    num_bits = Set{Int}()
    k = b
    while b >= 0
        num_bit = N ÷ 10^b
        N %= 10^b
        if !(num_bit in num_bits)
            if isempty(num_bits)
                le_num = num_bit - 1
            else
                le_num = num_bit - sum(nb < num_bit for nb in num_bits)
            end
            res += binomial(9 - k + b, b) * factorial(b) * (le_num)
            push!(num_bits, num_bit)
        else
            return ori - res
        end
        b -= 1
    end
    ori - res - 1
end"
"function least_interval(tasks::Vector{Char}, n::Int)::Int
    counter = fill(0, 26)
    for ch in tasks
        counter[UInt8(ch) - 0x40] += 1
    end
    sort!(counter, rev = true)
    res = (n + 1) * counter[1] - n
    for i in 2:26
        if counter[i] == counter[i - 1]
            res += 1
        else
            break
        end
    end
    return max(length(tasks), res)
end
least_interval(['A','A','A','B','B','B'], 2)"
"min_flip(a, b, c) = min_flip(a|>Int32, b|>Int32, c|>Int32)
function min_flip(a::Int32, b::Int32, c::Int32)
    sa, sb, sc = bitstring.([a, b, c])
    res = 0
    for i in 1:32
        if sc[i] == '1' 
            (sa[i] == '0' == sb[i]) && (res += 1)
        else
            res += (sa[i] == '1') + (sb[i] == '1')
        end
    end
    res
end"
"function count_bits(num::Int)
    res = fill(1, num)
    for i in 2:num
        res[i] = res[i >> 1] + (i & 1)
    end
    pushfirst!(res, 0)
end"
"function video_stitching(clips::Vector{Vector{Int}}, time::Int)
    max_next = fill(0, time)
    last, prev, res = 1, 1, 0
    for it in clips
        max_next[it[1] + 1] = max(max_next[it[1] + 1], it[2] + 1)
    end
    for i in 1:time
        last = max(last, max_next[i])
        i == last && return -1
        if i == prev
            res += 1
            prev = last
        end
    end
    return res
end"
"function sum_subseq_widths(A::Vector{Int})
    MOD = Int(1e9 + 7)
    len = length(A)
    sort!(A)
    pow = fill(2, len)
    for i in 2:len
        pow[i] = (pow[i - 1] << 1) % MOD
    end
    res = 0
    for i in 2:(len - 1)
        res += (A[i]) * ((pow[i - 1] - pow[len - i])) % MOD
    end
    return mod1((res + (A[end] - A[1]) * (pow[len - 1] - 1) % MOD), MOD)
end"
"function solve_equation(equation::AbstractString)
    function removex(expr)
        isempty(expr) && return [0, 0]
        last(expr) == 'x' || return [parse(Int, expr), 0]
        expr == ""x"" && return [0, 1]
        return [0, parse(Int, expr[1:(end - 1)])]
    end

    function removesub(expr)
        exprs = split(expr, '-')
        pos = removex(first(exprs))
        return length(exprs) == 1 ? pos : pos - sum(removex.(@view(exprs[2:end])))
    end

    removeplus(expr) = sum(removesub.(split(expr, '+')))
    left, right = removeplus.(split(equation, '='))
    num, den = left - right
    ## 0x + b = 0
    den == 0 && return num == 0 ? ""Infinite solutions"" : ""No solution""
    return ""x=$(-Int(num/den))""
end"
"function my_pow(x::Float64, n::Int)::Float64
    n == 0 && return 1
    if n < 0
        x, n = 1 / x, -n
    end
    res, extra = x, 1
    while n > 1
        n & 1 == 1 && (extra *= res)
        res *= res
        n >>= 1
    end
    return res * extra
end"
"function min_eating_speed(piles::Vector{Int}, h::Int)::Int
    function possible(mid)
        t = 0
        for pile in piles
            t += cld(pile, mid)
        end
        return t <= h
    end

    left, right = 1, maximum(piles)
    while left <= right
        mid = (left + right) >> 1
        if possible(mid)
            right = mid - 1
        else
            left = mid + 1
        end
    end

    return left
end"
"function hamming_distance(x::Int, y::Int)
    res = 0
    while x != 0 || y != 0
        res += (x & 1) ⊻ (y & 1)
        x >>= 1
        y >>= 1
    end
    res
end"
"function maximum_subarray(nums::Vector{Int})::Int
    pre, max_res = 0, nums[1]
    for num in nums
        pre = max(pre + num, num)
        max_res = max(pre, max_res)
    end
    return max_res
end"
"mutable struct SegmentTree{T<:Real}
    n::Int
    tree::Vector{T}

    function SegmentTree(nums::Vector{T}) where {T}
        n = length(nums)
        tree = append!(zeros(Int, n - 1), nums)
        for i in (n - 1):-1:1
            tree[i] = tree[i << 1] + tree[i << 1 | 1]
        end
        return new{T}(n, tree)
    end
end

function update!(ST::SegmentTree, ind::Int, val::Int)::Nothing
    tree = ST.tree
    ind += ST.n - 1
    delta = val - tree[ind]
    while ind > 0
        tree[ind] += delta
        ind >>= 1
    end
end

function sum_range(ST::SegmentTree, left::Int, right::Int)::Int
    left += ST.n - 1
    right += ST.n - 1
    res, tree = 0, ST.tree
    while left <= right
        if isodd(left) ## right child
            res += tree[left] ## record outside value
            left += 1
        end
        left >>= 1
        if iseven(right) ## left child
            res += tree[right] ## record outside value
            right -= 1
        end
        right >>= 1
    end
    return res
end"
"function minimum_total(triangle::Vector{Vector{Int}})
    length(triangle) == 1 && return triangle[1][1]
    dp = fill(0, length(triangle))
    tmp = dp[:]
    dp[1:2] = triangle[2] .+ triangle[1][1]
    for i in 3:length(triangle)
        tmp[1] = dp[1] + triangle[i][1]
        for j in 2:(i - 1)
            tmp[j] = min(dp[j], dp[j - 1]) + triangle[i][j]
        end
        tmp[i] = dp[i - 1] + triangle[i][i]
        tmp, dp = dp, tmp
    end
    return minimum(dp)
end"
"function update_matrix(mat::Matrix{Int})
    m, n = size(mat)
    dist = fill(typemax(Int) >> 1, m, n)
    for I in CartesianIndices(mat)
        (mat[I] == 0) && (dist[I] = 0)
    end
    for i in 1:m, j in 1:n
        (i - 1 >= 1) && (dist[i, j] = min(dist[i, j], dist[i - 1, j] + 1))
        (j - 1 >= 1) && (dist[i, j] = min(dist[i, j], dist[i, j - 1] + 1))
    end
    for i in m:-1:1, j in n:-1:1
        (i + 1 <= m) && (dist[i, j] = min(dist[i, j], dist[i + 1, j] + 1))
        (j + 1 <= n) && (dist[i, j] = min(dist[i, j], dist[i, j + 1] + 1))
    end
    return dist
end"
"Base.isless(l1::ListNode, l2::ListNode) = l1.val < l2.val

function merge_k_lists(lists::Vector{T}) where {T<:Union{ListNode{Int},Nothing}}
    pq = BinaryMinHeap{ListNode{Int}}()
    for l in lists
        isnothing(l) || push!(pq, l)
    end
    res = ListNode{Int}()
    p = res
    while !isempty(pq)
        tp_list = pop!(pq)
        p = p.next = tp_list
        tp_list = tp_list.next
        isnothing(tp_list) || push!(pq, tp_list)
    end
    return res.next
end"
"defanging_ip_address(ip_address::String) = replace(ip_address, ""."" => ""[.]"")"
"function rotate_right(head::ListNode, k::Int)::ListNode
    isnothing(head) && return head

    last_element, length = head, 1
    while !isnothing(next(last_element))
        last_element = next(last_element)
        length += 1
    end

    k = k % length
    next!(last_element, head)

    temp_element = head
    for _ = 0:(length-k-2)
        temp_element = next(temp_element)
    end

    answer = next(temp_element)
    next!(temp_element, nothing)

    return answer
end"
"function min_moves_453(nums::Vector{Int})
    sum(nums) - minimum(nums) * length(nums)
end"
"function increasing_triplet(nums::Vector{Int})
    fst_min = scd_min = nums[1]
    len = length(nums)
    idx = 2
    while idx <= len
        (nums[idx] != fst_min) && break
        idx += 1
    end
    (idx >= len) && return false
    fst_min, scd_min = minmax(fst_min, nums[idx])
    for num in @view(nums[(idx + 1):end])
        (num > scd_min) && return true
        scd_min = num
        fst_min, scd_min = minmax(fst_min, scd_min)
    end
    return false
end"
"function is_valid_sudoku(board::Vector{Vector{Char}})::Bool
    function check_line(i::Int)::Bool
        s = replace(join(board[i]), ""."" => """")
        return length(s) == length(Set{Char}(s))
    end
    function check_col(i::Int)::Bool
        s = replace(join(board[k][i] for k in 1:9), '.' => """")
        return length(s) == length(Set{Char}(s))
    end
    function check_box(i::Int, j::Int)::Bool
        s = replace(join(board[i + p1][j + p2] for p1 in 1:3 for p2 in 1:3), ""."" => """")
        return length(s) == length(Set{Char}(s))
    end
    return all(check_line(i) && check_col(i) for i in 1:9) &&
           all(check_box(3 * (i - 1), 3 * (j - 1)) for i in 1:3 for j in 1:3)
end"
"count_odd_numbers(low::Int, high::Int) = (high - low + 1 + (low & 1)) >> 1"
"function num_submatrix_sum_target(matrix::AbstractMatrix{Int}, target::Int)
    m, n = size(matrix)
    m > n && return num_submatrix_sum_target(matrix', target)
    pref_sum = OffsetArray(fill(0, m + 1, n + 1), -1, -1)
    
    for i in 1:m, j in 1:n
        pref_sum[i, j] = pref_sum[i - 1, j] + pref_sum[i, j - 1] + matrix[i, j] - pref_sum[i - 1, j - 1]
    end
    res = 0
    for tp in 1:m, bot in tp:m
        sum_cnt = Dict{Int, Int}()
        for r in 1:n
            rows_sum = pref_sum[bot, r] - pref_sum[tp - 1, r]
            rows_sum == target && (res += 1)
            res += get(sum_cnt, rows_sum - target, 0)
            sum_cnt[rows_sum] = get(sum_cnt, rows_sum, 0) + 1
        end
    end
    return res
end"
"function num_rook_captures(board::Matrix{Char})::Int
    res = 0
    i, j = findfirst(==('R'), board).I

    for v in (
        @view(board[i, (j + 1):end]),       ## right
        @view(board[i, (j - 1):-1:1]),      ## left
        @view(board[(i - 1):-1:1, j]),      ## up
        @view(board[(i + 1):end, j]),       ## down
    )
        x_ind = findfirst(!=('.'), v)
        if !isnothing(x_ind) && v[x_ind] == 'p'
            res += 1
        end
    end
    return res
end"
"function optimal_division(nums::Vector{Int})
    (length(nums) == 1) && return string(nums[1])
    (length(nums) == 2) && return string(nums[1]) * ""/"" * string(nums[1])
    res = ""$(nums[1])/($(nums[2])""
    for i in 3:length(nums)
        res *= ""/$(nums[i])""
    end
    return res * "")""
end"
"function longest_univalue_path(root::TreeNode{Int})
    res = 0
    function lup(root::TreeNode{Int})
        r2 = 1
        rl = lup(root.left)
        rr = lup(root.right)
        r = max(rl, rr) + 1
        if rl != 0 && root.val == root.left.val
            r2 += rl
        end
        if rr != 0 && root.val == root.right.val
            r2 += rr
        end
        res = max(r, res)
        return r
    end
    lup(::Nothing) = 0
    lup(root)
    return res - 1
end"
"function largest_divisible_subset(nums::Vector{Int})
    sort!(nums)
    len = length(nums)
    dp = fill(1, len)
    prev = fill(0, len)
    for i in 2:len, j in 1:(i - 1)
        if nums[i] % nums[j] == 0 && dp[i] < dp[j] + 1
            dp[i] = dp[j] + 1
            prev[i] = j
        end
    end
    idx = argmax(dp)
    res =  Int[]
    while idx != 0
        push!(res, nums[idx])
        idx = prev[idx]
    end
    return res
end"
"function validTicTacToe(board::Array{Char})::Bool
    n_X, n_O = 0, 0

    for x in board
        if x == 'X'
            n_X += 1
        elseif x == 'O'
            n_O += 1
        end
    end

    if n_O > n_X || n_X >= n_O + 2
        false
    elseif n_X >= 3
        if n_X == n_O
            if is_win(board, 'X')
                false  ## Impossible! n_X should == x_O + 1
            else
                true
            end
        else
            ## @assert n_X == n_O + 1
            if is_win(board, 'O')
                false  ## Impossible!
            else
                true
            end
        end
    else
        true
    end
end

function is_win(b, x)
    return b[1] == b[2] == b[3] == x ||
           b[4] == b[5] == b[6] == x ||
           b[7] == b[8] == b[9] == x ||
           b[1] == b[4] == b[7] == x ||
           b[2] == b[5] == b[8] == x ||
           b[3] == b[6] == b[9] == x ||
           b[1] == b[5] == b[9] == x ||
           b[3] == b[5] == b[7] == x
end"
"function level_order(root::Union{Nothing, TreeNode{Int}})
    isnothing(root) && return Int[]
    q = TreeNode{Int}[]
    q2 = TreeNode{Int}[]
    res = Vector{Int}[]
    push!(q, root)
    while !isempty(q)
        push!(res, Int[])
        while !isempty(q)
            fst = popfirst!(q)
            push!(res[end], fst.val)
            !isnothing(fst.left) && push!(q2, fst.left) 
            !isnothing(fst.right) && push!(q2, fst.right)
        end
        q, q2 = q2, q
    end    
    return res
end"
"function leaf_similar(root1::TreeNode{V}, root2::TreeNode{V})::Bool where {V}
    leaves1 = V[]
    leaves2 = V[]
    find_leaves!(root1, leaves1)
    find_leaves!(root2, leaves2)
    return leaves1 == leaves2
end

function find_leaves!(t::TreeNode, leaves)
    if isnothing(t.left) && isnothing(t.right)
        push!(leaves, t.val)
    else
        find_leaves!(t.left, leaves)
        find_leaves!(t.right, leaves)
    end
end

find_leaves!(::Nothing, leaves) = nothing"
"function is_valid_abc_str(s::String)
    while occursin(""abc"", s) 
        s = replace(s, ""abc"" => """")
    end
    return s == """"
end"
"function majority_element(nums::Vector{Int})::Int
    res = vote = 0
    for num in nums
        if vote == 0
            vote += 1
            res = num
        else
            vote += (res == num) ? 1 : -1
        end
    end
    return res
end"
"using OffsetArrays
function largest_number(cost::Vector{Int}, target::Int)::BigInt
    dp = OffsetArray(fill(typemin(Int), target + 1), -1)
    dp[0] = 0
    for c in cost, j in c:target
        dp[j] = max(dp[j], dp[j - c] + 1)
    end
    res = big(0)
    dp[end] < 0 && return res
    for i in 9:-1:1
        c = cost[i]
        while target >= c && dp[target] == dp[target - c] + 1
            res = res * 10 + i
            target -= c
        end
    end
    return res
end"
"function is_boomerang(points::Vector{Vector{Int}})
    p1, p2, p3 = points
    return (p1[1] - p2[1]) * (p1[2] - p3[2]) != (p1[1] - p3[1]) * (p1[2] - p2[2])
end"
"function min_days_1553(n::Int)
    memo = Dict{Int, Int}()
    memo[0] = 0
    memo[1] = 1
    function min_days(n::Int)
        if haskey(memo, n)
            return memo[n]
        end
        return memo[n] = 1 + min(min_days(n ÷ 2) + n % 2, min_days(n ÷ 3) + n % 3)
    end
    min_days(n)
end"
"function find_closest_elements(arr::Vector{Int}, k::Int, x::Int)
    res = Int[]
    j = searchsortedfirst(arr, x)
    i = j - 1
    for _ in 1:k
        if i == 0 || (j <= length(arr) && arr[j] - x < x - arr[i])
            push!(res, arr[j])
            j += 1
        else
            pushfirst!(res, arr[i])
            i -= 1
        end
    end
    return res
end"
"function find_anagrams(s::String, p::String)
    len = length(p)
    cntp = fill(0, 26)
    cnts = cntp[:]
    res = Int[]
    for c in p
        cntp[c - 'a' + 1] += 1
    end
    for i in 1:len-1
        cnts[s[i] - 'a' + 1] += 1
    end
    for i in len:length(s)
        cnts[s[i] - 'a' + 1] += 1
        cnts == cntp && push!(res, i - len + 1)
        cnts[s[i - len + 1] - 'a' + 1] -= 1        
    end
    return res
end"
"function find_all_numbers_disappeared_in_an_array(arr::Vector{Int})
    return setdiff(eachindex(arr), arr)
end

## add your code here:"
"function complex_number_multiply(num1::String, num2::String)
    Ct = Complex{Int}
    mult = parse(Ct, num1) * parse(Ct, num2)
    return ""$(mult.re)+$(mult.im)i""
end"
"function max_profit_121(prices::Vector{Int})::Int
    min_cost, profit = prices[1], 0
    for price in @view prices[2:end]
        profit = max(profit, price - min_cost)
        min_cost = min(min_cost, price)
    end
    return profit
end"
"bst_to_gst(::Nothing) = nothing
function bst_to_gst(root::TreeNode{Int})::TreeNode{Int}
    s = 0
    rev_first_ord(::Nothing) = nothing
    function rev_first_ord(node::TreeNode{Int})
        rev_first_ord(node.right)
        s += node.val
        node.val = s
        return rev_first_ord(node.left)
    end
    rev_first_ord(root)
    return root
end"
"function max_ancestor_diff(root::TreeNode{Int})
    res = 0
    function min_max_descendant(root::TreeNode{Int})
        minres, maxres = root.val, root.val
        for child in (:left, :right)
            cd_node = getproperty(root, child)
            isnothing(cd_node) && continue
            minl, maxl = min_max_descendant(cd_node)
            res = max(res, abs(root.val - minl), abs(root.val - maxl))
            minres = min(minres, minl)
            maxres = max(maxres, maxl)
        end
        return minres, maxres
    end
    min_max_descendant(root)
    return res
end"
"function right_side_view(root::TreeNode{Int})::Vector{Int}
    q = Queue{Pair{TreeNode{Int}, Int}}()
    res = Int[]
    enqueue!(q, Pair(root, 1))
    while !isempty(q)
        nd, layer = dequeue!(q)
        (nd.left !== nothing) && enqueue!(q, Pair(nd.left, layer + 1))
        (nd.right !== nothing) && enqueue!(q, Pair(nd.right, layer + 1))
        (isempty(q) || layer < first(q).second) && (push!(res, nd.val))
    end
    res
end"
"using DataStructures

## Double Pointers
function check_inclusion(s1::String, s2::String)::Bool
    equal2c1(c::Accumulator) = all(c[i] == c1[i] for i in keys(c1))
    c1, n1, n2 = counter(s1), length(s1), length(s2)
    n2 < n1 && return false
    c2 = counter(s2[1:n1])
    equal2c1(c2) && return true
    for (i, j) in zip(1:(n2 - n1), (n1 + 1):n2)
        c2[s2[i]] -= 1
        c2[s2[j]] += 1
        equal2c1(c2) && return true
    end
    return false
end"
"function remove_duplicates(S::String)::String
    stk = Char[]

    for ch in S
        if !isempty(stk) && stk[end] == ch
            pop!(stk)
        else
            push!(stk, ch)
        end
    end

    return join(stk)
end"
"function clumsy(N::Int)
    if N <= 4
        return [1, 2, 6, 7][N]
    end
    mod = 1 + (N & 3)
    return N + [1, 2, 2, -1][mod]
end"
"function median_sliding_window(nums::Vector{Int}, k::Int)
    tree = AVLTree{Tuple{Int, Int}}()
    res = Float64[]
    for i in 1:length(nums)
        push!(tree, (nums[i], i))
        if i ≥ k
            push!(res, (tree[k ÷ 2 + 1][1] + tree[(k - 1) ÷ 2 + 1][1]) / 2)
            delete!(tree, (nums[i - k + 1], i - k + 1))
        end
    end
    res
end"
"function hamming_weight(n::UInt32)::Int
    count = 0
    while n > 0
        n &= n - 1
        count += 1
    end

    return count
end"
"function avoid_flood(rains::Vector{Int})::Vector{Int}
    n = length(rains)
    options = [1 for _ = 1:n]
    seen = Dict{Int,Int}()
    dry_days = Vector{Int}()

    for (day, lake) in enumerate(rains)
        ## if no rain this day, record the day
        if rains[day] == 0
            push!(dry_days, day)
            ## if rain this day
        else
            options[day] = -1
            ## if lake has been rained
            if haskey(seen, lake)
                (isempty(dry_days) || dry_days[end] < seen[lake]) && return []
                pos = searchsortedfirst(dry_days, seen[lake])
                options[dry_days[pos]] = lake
                ## delete the dry_day we have used
                deleteat!(dry_days, pos)
            end

            seen[lake] = day
        end
    end

    return options

    ## ## for bigger testcase, the following code is much better
    ## n = length(rains)
    ## options = fill(1, n)
    ## seen = Dict{Int,Int}()
    ## dry_days = SortedSet{Int}()

    ## for (day, lake) in enumerate(rains)
    ##     ## if no rain this day, record the day
    ##     if rains[day] == 0
    ##         push!(dry_days, day)
    ##         ## if rain this day
    ##     else
    ##         options[day] = -1
    ##         ## if lake has been rained
    ##         if haskey(seen, lake)
    ##             (isempty(dry_days) || last(dry_days) < seen[lake]) && return []
    ##             semitoken = searchsortedfirst(dry_days, seen[lake])
    ##             options[deref((dry_days, semitoken))] = lake
    ##             ## delete the dry_day we have used
    ##             delete!((dry_days, semitoken))
    ##         end

    ##         seen[lake] = day
    ##     end
    ## end

    ## return options
end"
"function xor_operation(n::Int, start::Int)
    res = 0
    for _ in 1:n
        res ⊻= start
        start += 2
    end
    return res
end"
"function reverse_only_letters(s::String)
    chars = codeunits(s)[:]
    letters = @view(chars[isletter.(Char.(chars))])
    reverse!(letters)
    return String(chars)
end"
"function _generate!(p::String, left::Int, right::Int, res::Vector{String})
    if right == 0
        push!(res, p)
    else
        if left > 0
            _generate!(string(p, ""(""), left - 1, right, res)
        end

        if right > left
            _generate!(string(p, "")""), left, right - 1, res)
        end
    end
end

function generate_parenthesis(n::Int)::Vector{String}
    res = String[]
    _generate!("""", n, n, res)
    return res
end"
"function longest_palindrome(s::String)::AbstractString
    res = """"
    for i in 1:length(s)
        s_odd = _longest_palindrome(s, i, i)
        if length(s_odd) > length(res)
            res = s_odd
        end
        s_even = _longest_palindrome(s, i, i + 1)
        if length(s_even) > length(res)
            res = s_even
        end
    end
    return res
end

function _longest_palindrome(s, l, r)
    while l >= 1 && r <= length(s) && s[l] == s[r]
        l -= 1
        r += 1
    end
    return SubString(s, l + 1, r - 1)
end"
"function combination_sum3(k::Int, n::Int)
    function combination_sum3(k::Int, n::Int, s::Int)::Vector{Vector{Int}}
        if s + k - 1 > 9 || sum(s:(s + k - 1)) > n
            return []
        elseif k == 1 && s == n
            return [[n]]
        end
        choose_s = combination_sum3(k - 1, n - s, s + 1)
        notchoose_s = combination_sum3(k, n, s + 1)
        return [[[s, cs...] for cs in choose_s]..., notchoose_s...]
    end
    return combination_sum3(k, n, 1)
end"
"function num_sub(s::String)
    ss = split(s, '0')
    return sum(binomial(length(subs) + 1, 2) for subs in ss)
end"
remove_palindromic_subsequences(s::String) = (s == reverse(s)) ? 1 : 2
sort_array(nums::Vector{Int}) = sort!(nums)
"function max_product(words::Vector{String})
    mp = Dict{UInt32, Int}()    
    for word in words
        init = zero(UInt32)
        for c in word
            init |= UInt32(1) << (c - 'a')
        end
        mp[init] = max(length(word), get(mp, init, 0))
    end
    res = 0
    for x in keys(mp), y in keys(mp)
        (x & y == 0) && (res = max(res, mp[x] * mp[y]))        
    end
    return res
end"
"function check_straight_line(coordinates::Vector{Vector{Int}})::Bool
    coordinates .-= Ref(coordinates[1])
    slope = coordinates[2][1]//coordinates[2][2]
    for i in 3:length(coordinates)
        (coordinates[i][1]//coordinates[i][2] != slope) && (return false)
    end
    return true
end"
"function min_cost_1578(s::String, cost::Vector{Int})
    if length(s) == 0
        return 0
    end
    s *= ""0""
    lst_char = s[1]
    len, res = 1, 0
    for i in 2:length(s)
        if s[i] == lst_char
            len += 1
        else
            res += sum(cost[i-len:i-1]) - maximum(cost[i-len:i-1])
            len, lst_char = 1, s[i]
        end
    end
    res
end"
", DataStructures

function min_k_bit_flips(A::Vector{Int}, K::Int)
    len, res = length(A), 0
    q = Queue{Int}()
    for i in 1:len
        (!isempty(q) && first(q) <= i - K) && dequeue!(q)
        
        if (length(q) & 1) == A[i]
            (i + K - 1 > len) && return -1 
            enqueue!(q, i)
            res += 1
        end
    end
    res
end"
"function next_greater_element(num1::Vector{Int}, num2::Vector{Int})
    stk = Int[]
    res = fill(-1, length(num2))
    inv_idx = Dict{Int,Int}()
    for i in length(num2):-1:1
        inv_idx[num2[i]] = i
        while !isempty(stk) && stk[end] <= num2[i]
            pop!(stk)
        end
        res[i] = isempty(stk) ? -1 : stk[end]
        push!(stk, num2[i])
    end
    return [res[inv_idx[item]] for item in num1]
end"
"function beautiful_arrangement(n, k)
    res = [1:(n-k);]
    i = res[end] + 1
    j = n
    while i < j
        push!(res, j)
        j -= 1
        push!(res, i)
        i += 1
    end
    i == j && push!(res, i)
    return res
end"
"function search_left_border(left::Int, right::Int, key::Function)
    ## e.g. search_left_border(1, 10, >(3)) | returns 4
    while left <= right
        mid = left + (right - left) >> 1
        if key(mid) ## lies in the right part
            right = mid - 1
        else
            left = mid + 1
        end
    end
    return left
end

function search_in_rotated_array(nums::Vector{Int}, target::Int)::Int
    n, rightmost = length(nums), last(nums)
    if target > rightmost ## lies in the right side
        pos = search_left_border(1, n, i -> (nums[i] <= rightmost || nums[i] >= target))
        return pos <= n && nums[pos] == target ? pos - 1 : -1
    else
        pos = search_left_border(1, n, i -> (target <= nums[i] <= rightmost))
        return pos <= n && nums[pos] == target ? pos - 1 : -1
    end
end"
"postorder_traversal(::Nothing) = Int[]
function postorder_traversal(root::TreeNode)::Vector{Int}
    res, stack = Int[], [(root, -1)] ## -1 for left subtree, 1 for right subtree
    while !isempty(stack)
        cur = last(stack)
        if last(cur) == -1 ## search left subtree
            stack[end] = (cur[1], 1)
            !isnothing(cur[1].left) && push!(stack, (cur[1].left, -1))
        elseif last(cur) == 1 ## search right subtree
            stack[end] = (cur[1], 0)
            !isnothing(cur[1].right) && push!(stack, (cur[1].right, -1))
        else
            cur = pop!(stack)
            push!(res, cur[1].val) ## postorder traversal: put codes here
        end
    end
    return res
end

##### code template for inorder/preorder/postorder traversal #####
## function traversal(root::TreeNode)::Vector{Int}
##     res, stack = Int[], [(root, -1)] ## -1 for left subtree, 1 for right subtree
##     while !isempty(stack)
##         cur = last(stack)
##         if last(cur) == -1 ## search left subtree
##             stack[end] = (cur[1], 1)
##             ## preorder traversal: put codes here
##             !isnothing(cur[1].left) && push!(stack, (cur[1].left, -1))
##         elseif last(cur) == 1 ## search right subtree
##             stack[end] = (cur[1], 0)
##             ## inorder traversal: put codes here
##             !isnothing(cur[1].right) && push!(stack, (cur[1].right, -1))
##         else
##             cur = pop!(stack)
##             ## postorder traversal: put codes here
##         end
##     end
##     return res
## end"
"function has_cycle(head::Union{ListNode,Nothing})::Bool
    isnothing(head) && return false
    swift = slow = head
    while !isnothing(swift.next) && !isnothing(swift.next.next)
        slow, swift = slow.next, swift.next.next
        slow === swift && return true
    end
    return false
end"
"function merge_intervals(intervals::Vector{Vector{Int}})::Vector{Vector{Int}}
    result = Vector{Vector{Int}}([])
    for (a, b) in sort!(intervals, by = i -> i[1])
        if size(result, 1) > 0 && result[end][2] >= a
            result[end][2] = max(result[end][2], b)
        else
            push!(result, [a, b])
        end
    end
    return result
end"
"function original_digits(s::String)
    cnt = counter(s)
    n0 = cnt['z']
    n2 = cnt['w']
    n8 = cnt['g']
    n6 = cnt['x']
    n3 = cnt['t'] - n2 - n8
    n4 = cnt['r'] - n3 - n0
    n7 = cnt['s'] - n6
    n1 = cnt['o'] - n4 - n2 - n0
    n5 = cnt['v'] - n7
    n9 = cnt['i'] - n8 - n6 - n5
    ns = (n0, n1, n2, n3, n4, n5, n6, n7, n8, n9)
    return join(string(i - 1)^n for (i, n) in enumerate(ns))
end"
"function prefixes_div_by5(nums::Vector{Int})
    len = length(nums)
    res = fill(false, len)
    cur = 0
    for i in 1:len
        cur = cur * 2 + nums[i]
        cur % 5 == 0 && (res[i] = true)
    end
    return res
end"
"function longest_palindrome_subseq(s::String)
    len = length(s)
    dp = fill(0, len, len)
    for i in len:-1:1
        dp[i, i] = 1
        for j in i+1:len
            dp[i, j] = (s[i] == s[j]) ? dp[i + 1, j - 1] + 2 : max(dp[i + 1, j], dp[i, j - 1])
        end
    end
    return dp[1, len]
end"
"three_sum_closest(nums::Vector{Int}, target::Int) = three_sum_closest!(copy(nums), target)
function three_sum_closest!(nums::Vector{Int}, target::Int)::Int
    mindiff, n, res = Inf, length(sort!(nums)), 0
    for (i, first) in enumerate(nums)
        i > 1 && nums[i - 1] == first && continue
        left, right, newtarget = i + 1, n, target - first
        while left < right
            newsum = nums[left] + nums[right]
            newdiff = abs(newsum - newtarget)
            if newdiff < mindiff ## updates minimal difference
                newdiff == 0 && return target
                mindiff, res = newdiff, newsum + first
            elseif newsum > newtarget
                right -= 1
            else
                left += 1
            end
        end
    end
    return res
end"
"function min_swaps_couples(row::Vector{Int})
    len, ps, res = length(row), length(row) ÷ 2, 0
    grp = [Set{Int}() for i in 1:ps]
    for i in 1:2:len
        l, r = row[i] ÷ 2 + 1, row[i + 1] ÷ 2 + 1
        (l != r) && (push!(grp[l], r); push!(grp[r], l))
    end
    visited = fill(false, ps)
    q = Queue{Int}()
    for i in 1:ps
        visited[i] && continue
        enqueue!(q, i)
        visited[i] = true
        cnt = 0
        while !isempty(q)
            frt = dequeue!(q)
            cnt += 1
            for neighbor in grp[frt]
                visited[neighbor] && continue
                enqueue!(q, neighbor)
                visited[neighbor] = true
            end
        end
        res += cnt - 1
    end
    res
end"
"function custom_sort_string(S::String, T::String)
    letter_rank = fill(0, 128)
    for (idx, ch) in enumerate(codeunits(S)) 
        letter_rank[ch] = idx
    end
    u = codeunits(T)[:]
    sort!(u, by = x -> letter_rank[x])
    String(u)
end"
"function matrixReshape(nums::Vector{Vector{Int}}, r::Int, c::Int)
    m, n = length(nums), length(nums[1])

    m * n != r * c && return nums

    ans = [[0 for _ in 1:c] for _ in 1:r]

    for x in 0:(m * n - 1)
        ans[x ÷ c + 1][(x % c) + 1] = nums[x ÷ n + 1][(x % n) + 1]
    end

    return ans
end"
"function min_domino_rotations(A::Vector{Int}, B::Vector{Int})
    base1, base2 = A[1], B[1]
    cnt1, cnt2 = 0, 0
    for i = 1:length(A)
        !(base1 in (A[i], B[i])) && (base1 = 0)
        !(base2 in (A[i], B[i])) && (base2 = 0)
        if base1 == base2 == 0
            return -1
        end
        (base1 != 0 && A[i] != base1) && (cnt1 += 1)
        (base2 != 0 && A[i] != base2) && (cnt2 += 1)
    end
    res = length(A)
    (base1 != 0) && (res = min(base1, length(A) - base1))
    (base2 != 0) && (res = min(res, base2, length(A) - base2))
    res
end"
"struct MyHashSet
    buckets::Int
    table::Vector{Vector{T}} where {T}
    MyHashSet() = new(1009, [[] for _ = 1:1009])
end

hash_705(hash_set::MyHashSet, key::Int) = mod1(key, hash_set.buckets)

function add_705!(hash_set::MyHashSet, key)
    hash_key = hash_705(hash_set, key)

    key ∈ hash_set.table[hash_key] && return

    push!(hash_set.table[hash_key], key)
    return
end

function remove_705!(hash_set::MyHashSet, key::Int)
    hash_key = hash_705(hash_set, key)

    key ∉ hash_set.table[hash_key] && return

    deleteat!(hash_set.table[hash_key], hash_set.table[hash_key] .== key)
end

function contains_705(hash_set::MyHashSet, key::Int)
    hash_key = hash_705(hash_set, key)

    return key ∈ hash_set.table[hash_key]
end"
"function letter_case_permutation(s::String)
    ans = [""""]
    for i in s
        if isletter(i)
            tmp = ans[:]
            ans .*= lowercase(i)
            tmp .*= uppercase(i)
            append!(ans, tmp)
        else
            ans .*= i
        end
    end
    ans
end"
"function distribute_coins(root::TreeNode{Int})
    dfs(::Nothing) = 0
    function dfs(root::TreeNode{Int})
        l = dfs(root.left)        
        r = dfs(root.right)
        res = res + abs(l) + abs(r)
        root.val + l + r - 1
    end
    res = 0
    dfs(root)
    res
end"
"function can_transform(s::String, t::String)
    i, j = 1, 1
    len = length(s)
    len != length(t) && return false
    while i <= len || j <= len
        while i <= len && s[i] == 'X'; i += 1; end
        while j <= len && t[j] == 'X' ; j += 1; end
        ((i <= len) ⊻ (j <= len)) && return false
        if i <= len && j <= len
            (s[i] != t[j] || (s[i] == 'L' && i < j) || (s[i] == 'R' && i > j)) && return false
        end
        i += 1; j += 1
    end
    return true
end"
"function three_sum!(nums::Vector{Int})::Vector{NTuple{3,Int}}
    sort!(nums)
    n, res, pre = length(nums), NTuple{3,Int}[], NaN
    for (i, first) in enumerate(nums)
        first == pre && continue
        pre, left, right = first, i + 1, n
        while left < right
            total = nums[left] + nums[right]
            if total < -first
                left += 1
            elseif total > -first
                right -= 1
            else
                push!(res, (first, nums[left], nums[right]))
                pos = findfirst(!=(nums[left]), @view(nums[(left + 1):right]))
                isnothing(pos) ? break : left += pos
                pos = findfirst(!=(nums[right]), @view(nums[(right - 1):-1:left]))
                isnothing(pos) ? break : right -= pos
            end
        end
    end
    return res
end
three_sum(nums::Vector{Int}) = three_sum!(copy(nums))"
"function total_hamming_distance(nums)
    res, n = 0, length(nums)
    for i in 0:30
        c = 0
        for num in nums
            c += (num >> i) & 1
        end
        res += c * (n - c)
    end
    return res
end"
"function add_to_array_form(num::Vector{Int}, k::Int)::Vector{Int}
    n = length(num)
    i, val, carry = n, 0, 0
    res = Int[]

    while i > 0 || k != 0
        x = i > 0 ? num[i] : 0
        y = k != 0 ? k % 10 : 0

        val = x + y + carry
        append!(res, val % 10)
        carry = val ÷ 10
        i, k = i - 1, k ÷ 10
    end

    if carry > 0
        append!(res, carry)
    end

    return reverse(res)
end"
"function maximal_square(matrix::Matrix{Char})
    length(matrix) == 0 && return 0
    maxs = any(==('1'), matrix)
    maxs == 0 && return 0
    m, n = size(matrix)
    dp = fill(0, size(matrix))
    for i in 1:m
        dp[i, 1] = matrix[i, 1] == '1'
    end
    for j in 1:n
        dp[1, j] = matrix[1, j] == '1'
    end
    for i in 2:m, j in 2:n
        if matrix[i, j] == '1'
            dp[i, j] = min(dp[i, j - 1], dp[i - 1, j], dp[i - 1, j - 1]) + 1
            maxs = max(maxs, dp[i, j])
        end
    end
    return maxs * maxs
end"
"function contains_cycle(grid::Vector{Vector{String}})
    dirs = ((1, 0, 3), (-1, 0, 0), (0, 1, 1), (0, -1, 2))
    function bfs(grid::Vector{Vector{String}}, r::Int, c::Int)
        sym = grid[r][c]
        q_pos = Queue{Pair{Int, Int}}()
        q_dir = Queue{Int}()
        enqueue!(q_pos, Pair(r, c))
        enqueue!(q_dir, 0)
        visited[r, c] = true
        while !isempty(q_pos)
            pos = dequeue!(q_pos)
            dir = dequeue!(q_dir)
            for d in dirs
                nx, ny = pos.first + d[1], pos.second + d[2]
                if 0 < nx <= nr && 0 < ny <= nc && dir != d[3] && sym == grid[nx][ny]
                    if visited[nx, ny]
                        return true
                    else
                        visited[nx, ny] = true
                        enqueue!(q_pos, Pair(nx, ny))
                        enqueue!(q_dir, 3 - d[3])
                    end
                end
            end
        end
        false
    end
    nr, nc = length(grid), length(grid[1])
    visited = fill(false, nr, nc)
    for r in 1 : nr  
        for c in 1 : nc
            if !visited[r, c] && bfs(grid, r, c)
                ## println(grid[r][c])
                return true
            end
        end
    end
    return false    
end"
"function min_jumps_1345(arr::Vector{Int})::Int
    ## data initialize
    n, step = length(arr), 0
    nums = Dict{Int,Set}(x => Set{Int}() for x in Set{Int}(arr))
    for (i, val) in enumerate(arr)
        push!(nums[val], i)
    end
    ## BFS Search
    up_nums, up_inds, inds = Set{Int}([arr[1]]), Set{Int}([1]), Set{Int}([0, 1, n + 1])
    while !(n in up_inds)
        down_inds = Set{Int}()
        ## indexs by numbers
        for num in up_nums
            union!(down_inds, nums[num])
        end
        ## nearby indexs
        for i in up_inds
            push!(down_inds, i - 1)
            push!(down_inds, i + 1)
        end
        ## remove extra indexs
        for i in down_inds
            i in inds && delete!(down_inds, i)
        end
        up_inds, up_nums = down_inds, Set{Int}(arr[i] for i in down_inds)
        union!(inds, up_inds)
        step += 1
    end
    return step
end"
"single_number_136(nums::Vector{Int}) = reduce(⊻, nums)"
"function next_greater_elements(nums::Vector{Int})
    stk = Int[]
    res = fill(-1, size(nums))
    for rd in 1:2, (idx, num) in enumerate(nums)
        while !isempty(stk) && nums[stk[end]] < num
            res[pop!(stk)] = num
        end
        (rd == 1) && push!(stk, idx)
    end
    return res
end"
"function num_matching_subseq(S::String, words::Vector{String})
    map = Dict{Char, Vector{String}}((ch, []) for ch in 'a':'z')
    for w in words
        push!(map[w[1]], w[2:end])
    end
    res = 0
    for ch in S
        wds = String[]
        wds, map[ch] = map[ch], wds
        for w in wds
            if w == """"
                res += 1
            else
                push!(map[w[1]], w[2:end])
            end
        end
    end
    res
end"
"function smallest_repunit_div_by_k(K::Int)
    (K % 2 == 0 || K % 5 == 0) && (return -1)
    r, len = 0, 1
    while true
        r = (10 * r % K + 1) % K
        r == 0 && return len
        len += 1
    end
end"
"function kth_grammar(N::Int, K::Int)
    res = false
    for i in 1:N 
        iseven(K) && (res = !res)
        K = (K + 1) >> 1
    end
    res
end"
"function combination_sum_39(
    nums::Union{Vector{Int},SubArray}, target::Int
)::Vector{Vector{Int}}
    target == 0 && return [Int[]]
    isempty(nums) && return Vector{Int}[]
    res, num = Vector{Int}[], nums[end]
    for i in 0:(target ÷ num)
        for vec in combination_sum_39(@view(nums[1:(end - 1)]), target - i * num)
            append!(res, [append!(vec, fill(num, i))])
        end
    end
    return res
end"
"function unique_number_of_occurrences(arr::Vector{Int})
    counts = Dict{Int, Int}()
    for a in arr
        counts[a] = get(counts, a, 0) + 1
    end
    vs = values(counts)
    return length(vs) == length(unique(vs))
end

## add your code here:"
"function max_profit(inventory::Vector{Int}, orders::Int)
    rest = sum(inventory) - orders
    sort!(inventory)
    len = length(inventory)
    for n in inventory
        if rest ÷ len >= n
            len -= 1
            rest -= n
        else
            break
        end
    end
    q = rest ÷ len
    r = rest - q * len
    ret = 0
    for i in (length(inventory) - len + 1):length(inventory)
        ret += sum((q + 2):inventory[i])
    end
    ret += (q + 1) * (len - r)
    return ret % (10^9 + 7)
end"
"function search_matrix(matrix::Matrix{Int}, target::Int)::Bool
    row, col = size(matrix)
    i, j = row, 1

    while (i > 0 && j <= col)
        last = matrix[i, j]

        if (last == target)
            return true
        elseif last > target
            i -= 1
        else
            j += 1
        end
    end

    return false
end"
"function validate_stack_sequences(pushed::Vector{Int}, popped::Vector{Int})
    return validate_stack_sequences!(copy(pushed), popped)
end
function validate_stack_sequences!(pushed::Vector{Int}, popped::Vector{Int})::Bool
    stack = Int[]
    for num in popped
        while isempty(stack) || last(stack) != num
            isempty(pushed) && return false
            push!(stack, popfirst!(pushed))
        end
        pop!(stack)
    end
    return true
end"
"function kth_smallest_prime_fraction(arr::Vector{Int}, k::Int)
    hp = BinaryMinHeap(1 .// arr[2:end])
    next_prime = Dict((arr[i], arr[i+1]) for i in 1:length(arr)-1)
    while (k -= 1) > 0
        tp = pop!(hp)
        if next_prime[tp.num] < tp.den
            push!(hp, next_prime[tp.num] // tp.den)            
        end
    end
    return first(hp)
end"
"function find_max_length(nums::Vector{Int})
    dc = Dict(0 => 0)
    res = acc = 0
    @inbounds for i in eachindex(nums)
        acc += nums[i] == 0 ? -1 : 1
        haskey(dc, acc) ? res = max(res, i - dc[acc]) : dc[acc] = i
    end
    return res
end"
"function shift_grid(grid::Matrix{Int}, k::Int)::Matrix{Int}
    A = grid'
    res = Matrix(undef, size(A)...)
    LI = LinearIndices(A)

    for i in LI
        i′ = mod1(i + k, length(LI))
        res[i′] = A[i]
    end
    return res'
end"
"function max_depth_559(tree::Vector{Vector{Int}})
    isempty(tree) && return 0
    q = Queue{Tuple{Int, Int}}()
    enqueue!(q, (1, 1))
    res = 1
    while !isempty(q)
        frt = dequeue!(q)
        res = frt[2]
        for son in tree[frt[1]]
            enqueue!(q, (son, res + 1))
        end
    end
    res
end"
"function num_decodings(s)
    len = length(s)
    dp = fill(0, len + 1)
    dp[1] = 1
    for i in 1:len
        s[i] != '0' && (dp[i + 1] += dp[i])
        (i > 1 && s[i - 1] != '0' && parse(Int, s[(i - 1):i]) <= 26) &&
            (dp[i + 1] += dp[i - 1])
    end
    return dp[end]
end"
"function search704(nums::Vector{Int}, target::Int)
    res = searchsortedfirst(nums, target)
    nums[res] == target ? res : 0
end"
"function longest_common_subsequence(itr1, itr2)::Int32
    m, n = length(itr1) + 1, length(itr2) + 1
    dp = fill(0, m, n)

    for i in 2:m, j in 2:n
        dp[i, j] = (itr1[i - 1] == itr2[j - 1]) ? (dp[i - 1, j - 1] + 1) : max(dp[i - 1, j], dp[i, j - 1])
    end

    return dp[m, n]
end"
"function build_tree_inpost(inorder::AbstractArray, postorder::AbstractArray)::TreeNode
    root = TreeNode(last(postorder))
    pos = findfirst(==(root.val), inorder)
    pos != 1 && (
        root.left = build_tree_inpost(
            @view(inorder[1:(pos - 1)]), @view(postorder[1:(pos - 1)])
        )
    )
    pos != length(postorder) && (
        root.right = build_tree_inpost(
            @view(inorder[(pos + 1):end]), @view(postorder[pos:(end - 1)])
        )
    )
    return root
end"
"split_list_to_parts(::Nothing, k::Int)::Vector{Union{ListNode{Int},Nothing}} =
    fill(nothing, k)

function split_list_to_parts(
    head::ListNode{Int}, k::Int
)::Vector{Union{ListNode{Int},Nothing}}
    p = head
    len = length_of_list(head)
    first_m = mod(len, k)
    base_n = len ÷ k
    res = Vector{Union{ListNode{Int},Nothing}}(undef, k)
    for i in 1:k
        for _ in 1:(base_n - (i > first_m))
            p = p.next
        end
        res[i] = head
        if !isnothing(p)
            head = p.next
            p.next = nothing
        end
        p = head
    end
    return res
end"
"function get_pascal_row(row_index::Int)
    res = fill(1, row_index + 1)
    for i in 2:row_index
        res[2:i] .= @view(res[1:(i - 1)]) + @view(res[2:i])
    end
    res
end"
"function max_product(nums::Vector{Int})
    maxF = minF = res = nums[1]
    for num in @view nums[2:end]
        maxF, minF = max(maxF * num, minF * num, num), min(minF * num, maxF * num, num)
        res = max(res, maxF)
    end    
    res
end"
"using DataStructures
function maximum_requests(::Int, requests::Vector{Vector{Int}})::Int
    function is_valid_request(req)
        return counter(requests[i][1] for i in req) == counter(requests[i][2] for i in req)
    end
    ans, m = 0, length(requests)
    for k in 1:(1 << m)
        req = filter(i -> isodd(k >> (i - 1)), 1:m)
        ans = length(req) > ans && is_valid_request(req) ? length(req) : ans
    end
    return ans
end"
"function subsets_with_dup(nums::Vector{Int})::Vector{Vector{Int}}
    sort!(nums)
    res = Vector{Int}[Int[]]

    n = 0
    for (i, x) in enumerate(nums)
        if i == 1
            n = 1
        elseif nums[i] != nums[i - 1]
            n = length(res)
            ## n is used to record how many sets to skip in case nums[i+1] == nums[i]
        end

        if n == length(res)
            for j in 1:n
                push!(res, [res[j]..., nums[i]])
            end
        else
            for j in (length(res) - n + 1):length(res)
                push!(res, [res[j]..., nums[i]])
            end
        end
    end
    return res
end"
"function get_skyline(buildings::Vector{Vector{Int}})
    all = Tuple{Int, Int}[]
    res = Tuple{Int, Int}[]
    @inbounds for b in buildings
        push!(all, (b[1], -b[3]))
        push!(all, (b[2], b[3]))
    end
    sort!(all)

    heights = SortedMultiDict{Int, Nothing}()
    push!(heights, 0 => nothing)
    lst = (0, 0)
    for p in all
        p[2] < 0 ? push!(heights, -p[2] => nothing) : delete!((heights, searchsortedfirst(heights, p[2])))
        mh = last(heights).first
        if lst[2] != mh
            lst = (p[1], mh)
            push!(res, lst)
        end
    end
    return res
end"
"function merge_stones(stones::Vector{Int}, K::Int)
    len = length(stones)
    (len - 1) % (K - 1) != 0 && return -1
    pre = fill(0, len + 1)
    cumsum!(@view(pre[2:len + 1]), stones)
    dp = fill(0, len, len)
    for m in K:len, i in 1:(len - m + 1)
        dp[i, i + m - 1] = minimum(dp[i, k] + dp[k + 1, i + m - 1]
                               for k in i:(K - 1):(i + m - 2)) +
                           ((m - 1) % (K - 1) == 0 ? pre[i + m] - pre[i] : 0)
    end
    return dp[1, len]
end"
"""""""
function stone_game(piles::Vector{Int})
    len = length(piles)
    dp = Matrix{Int}(undef, len, len)
    for i in 1:len
        dp[i, i] = piles[i]
    end
    for i in (len - 1):-1:1, j in (i + 1):len
        dp[i, j] = max(piles[i] - dp[i + 1, j], piles[j] - dp[i, j - 1])
    end
    return dp[1, end] > 0
end
""""""
stone_game(::Vector{Int}) = true"
"function generate_matrix(n::Int)::Vector{Vector{Int}}
    mat = [fill(0, n) for _ = 1:n]
    i, j, di, dj = 1, 1, 0, 1

    for k = 1:n*n
        mat[i][j] = k
        if mat[mod1(i + di, n)][mod1(j + dj, n)] != 0
            di, dj = dj, -di
        end

        i += di
        j += dj
    end

    return mat
end"
"function find_min_154(nums::Vector{Int})
    left, right = 1, length(nums)
    while left < right
        mid = (left + right) ÷ 2
        if nums[mid] > nums[right]
            left = mid + 1
        elseif nums[mid] < nums[right]
            right = mid
        else
            right -= 1
        end
    end
    nums[left]
end"
"function min_distance(word1::String, word2::String)::Int32
    m, n = length(word1) + 1, length(word2) + 1
    dp = zeros(Int32, m, n)
    dp[:, 1] .= (1:m) .- 1
    dp[1, :] .= (1:n) .- 1

    for i in 2:m, j in 2:n
        dp[i, j] =
            1 + min(
                dp[i - 1, j - 1] - Int(word1[i - 1] == word2[j - 1]),
                dp[i, j - 1],
                dp[i - 1, j],
            )
    end
    return dp[end, end]
end"
"function can_measure_water(jug1_cap::Int, jug2_cap::Int, target::Int)
    target > jug1_cap + jug2_cap && return false
    return target % gcd(jug2_cap, jug1_cap) == 0 ? true : false
end"
"function get_sum371(a::Int, b::Int)::Int
    while b != 0
        carry = (a & b) << 1
        a = a ⊻ b
        b = carry
    end
    a
end"
"running_sum(arr::Vector{<:Number}) = cumsum!(arr, arr)"
"using Plots
using Statistics: mean
pyplot()

N    = 16
p    = 2
?    = [0,50]*(?/180) 
T    = 400
SNR  = 0
?    = 10^(-SNR/20)  # noise std

#----------------
# Data generation
#----------------
s = (randn(p,T)+1im*randn(p,T))/?2
A = exp.(1im*(0:N-1)*?')
b = ?*(randn(N,T)+1im*randn(N,T))/?2
data    = A*s + b

#---------------------
# Periodogram
#---------------------
nb_points = 360
d?  = exp.(-1im.*(LinRange(-?, ?, nb_points))*(0:N-1)')
S_p       = (1/N)*abs.(d?* data).^2 # Fourier spectrum
S_p_moy   = mean(S_p,dims=2);"
"fig = plot()
for k=1:10
    fig =plot!(range(-180,stop=180,length=nb_points),S_p[:,k],label="""")
end
max_per = maximum(S_p)
fig = plot!([?[1],?[1]]*(180/?),[0,max_per],c=:blue,label=""source 1"")
fig = plot!([?[2],?[2]]*(180/?),[0,max_per],c=:green,label=""source 2"")
fig = plot!(range(-180,stop=180,length=nb_points), xlims=(-180,180),ylims=(0,80),
            lw=2,c=:red, S_p_moy,label=""averaged"",title=(""Periodogram""))"
"#------------------------------------------------
# Influence of second source location
# test for N=16,32,64
#------------------------------------------------
N         = 16
p         = 2
?         = [0 50]*(?/180)
T         = 400
SNR       = 20
?         = 10^(-SNR/20) # noise std
nb_points = 361

fig = plot()
for k=1:4
    ?       = [0, 50-5*k]*(?/180)
    s       = (randn(p,T)+1im*randn(p,T))/?2
    A       = exp.(1im*(0:N-1)*?')
    b       = ?*(randn(N,T)+1im*randn(N,T))/?2
    data    = A*s + b 
    d?      = exp.(-1im.*(LinRange(-?, ?, nb_points))*(0:N-1)')
    S_p     = (1/N)*abs.(d?* data).^2 # Fourier spectrum
    S_p_moy = mean(S_p,dims=2)
    fig     = plot!(range(-180,stop=180,length=nb_points),S_p_moy,label=""??=$(50-10*k)"")
end
plot!(fig, xlims=(-180,180), title=""Periodogram: ???[10,40], N=$N"")"
"#----------------
# MUSIC algorithm
#----------------
using LinearAlgebra: eigen
#----------------
# Main parameters
#----------------
N         = 16
p         = 2
?         = [0,10]*(?/180)
T         = 400
SNR       = 0
?         = 10^(-SNR/20)
nb_points = 361

#----------------
# Data generation
#----------------
s    = (randn(p,T)+1im*randn(p,T))/?2
A    = exp.(1im*(0:N-1)*?')
b    = ?*(randn(N,T)+1im*randn(N,T))/?2
data = A*s + b
#----------------------
# Localization function
#----------------------
Ry  = (1/T)*data*data'
E,V = eigen(Ry)
U   = V[:,1:N-p] 
g   = 1 ./sum(abs.(U'*exp.(1im*(0:N-1)*(LinRange(-?, ?, nb_points))')).^2, dims=1)'# MUSIC spectrum
fig = plot()
fig = plot!([?[1],?[1]]*(180/?),[0,max_per],c=:blue,label=""source 1"")
fig = plot!([?[2],?[2]]*(180/?),[0,max_per],c=:green,label=""source 2"")
fig = plot!(range(-180,stop=180,length=nb_points),g,c=:red,ylims=(0,50),
            label=""MUSIC spectrum"",title=""Music spectrum"")
# periodogram
d?      = exp.(-1im.*(LinRange(-?, ?, nb_points))*(0:N-1)')

S_p     = (1/N)*abs.(d?* data).^2  # Fourier spectrum
S_p_moy = mean(S_p,dims=2)
fig     = plot!(range(-180,stop=180,length=nb_points),S_p_moy,label=""Periodogram"")"
"using Plots
pyplot()
N     = 6;                  # number of sensors
?     = (?/180)*[0,30]      # phase of sources
T     = 1000                # number of observation vectors
SNR   = 1                   # signal o noise ratio
?     = 10^(-SNR/20)        # noise std (signals power = 1)

# Signals generation
#-------------------
s    = hcat(sign.(sin.(2?*0.008*(1:T))), sqrt(2)*cos.(2?*0.003*(1:T)))' #square and cosine signals
A    = exp.(1im*(0:N-1)*?')
b    = ?*(randn(N,T)+1im*randn(N,T))/?2
data = A*s +b
p1 = plot(1:T, s[1,:], label=""square signal"")
p2 = plot(1:T, s[2,:], label=""cosine signal"")
plot(p1, p2,layout=(1,2),size=(800,200))"
"# Beamformer based on phase correction
#--------------------------------------
d(?)    = exp.(im*(0:N-1)*?)

# Beamformer source 1
h?? = (1/N)*d(?[1])
Z = h??'*data
? = range(-?,?,length=361)
p1=plot(1:T,[real.(Z)',s[1,:]],label="""",title=""PR:s1_1"")
p2=plot((180/pi)*?, abs.(h??'*exp.(1im*(0:N-1)*?'))', label=""s_1"",title=""array function"" )
p2=plot!([?[1],?[1]]*(180/?),[0,1.5],c=:blue,label=""source 1"")
p2=plot!([?[2],?[2]]*(180/?),[0,1.5],c=:green,label=""source 2"")

# Beamformer source 2
h?? = (1/N)*d(?[2])
Z = h??'*data
? = range(-?,?,length=361)
p3=plot(1:T,[real.(Z)',s[1,:]],label="""",title=""PR:s2_1"")
p4=plot((180/pi)*?, abs.(h??'*exp.(1im*(0:N-1)*?'))', label=""s_2"",title=""array function"" )
p4=plot!([?[1],?[1]]*(180/?),[0,1.5],c=:blue,label=""source 1"")
p4=plot!([?[2],?[2]]*(180/?),[0,1.5],c=:green,label=""source 2"")
plot(p1,p2,p3,p4, layout=(2,2), size=(700,300))"
"K = 6
S?? = zeros(K)
plots =Dict()

for k in 1:K
    n = 2^k
    data= exp.(im*(0:n-1)*?') * s + ?*randn(n,T)
    h?? = (1/n)*exp.(1im*(0:n-1)*?[1])
    Z = h??'*data
    S??[k] = sum(s[1,:].^2)/real((s[1,:].-Z)'*(s[1,:].-Z))[1]
    plots[""p$k""] =plot((180/?)*?,(abs.(h??'*exp.(1im*((0:n-1)*?'))))',label=""N=$n"")
end
plot(plots[""p1""], plots[""p2""], plots[""p3""], plots[""p4""], plots[""p5""], plots[""p6""])"
"using LinearAlgebra: norm, tr, inv, eigvals
using Plots
pyplot()
#1
ns = 10000;
symb = rand((-1,1), ns)

#2-3
h = [1,0.8,0.3]
h /= norm(h)
# Convolvs the symbols with the filter 
# Let denote Y the output of such filter 

Y = [sum([symb[i+1-k]*h[k] for  k=1:min(3,i)]) for i=1:ns]

SNR = 20

# calcul of ? noise such that SNR = -40*ln(?)/ln(10)

? = exp(-SNR*log(10)/20)
noise = ?*randn(ns)
data = Y + noise;"
"# Figures
sign = 2*(data.>=0) .-1
scatter(symb[1:20], label=""input signal"")
scatter!(data[1:20], label=""output signal with noise"")
scatter!(sign[1:20], label=""sign of the output"")
plot!(zeros(20), label=""zero"")
title!(""The input and output signals"")"
"#4
println(""Pe without equalization and without noise = $(sum((abs.(Y-symb)).>1)/ns)"")
print(""Pe without equalization = $(sum((abs.(data-symb)).>1)/ns)"")"
"5#

# data
ns = 10000;
symb = rand((-1,1), ns)
h = [1,0.8,0.3]
h /= norm(h)
Y = [sum([symb[i+1-k]*h[k] for  k=1:min(3,i)]) for i=1:ns]
SNR = 20
? = exp(-SNR*log(10)/20)
noise = ?*randn(ns)
data = Y + noise;

l_w = 10
Y_ = reshape(data[end:-1:1],(l_w, 1000))
# Rx = E(M*M')
Rx = Y_*Y_'/1000
# calcul of step size = 1/2 * ?_max 
# we can take ?_max = = 2/?_max or 2/(l_w*?)
?? = maximum(eigvals(Rx))
? = 1/(l_w*tr(Rx))
#? = l_w/?? ; print(?)
rxd = Y_*symb[ns:-l_w:1]/1000
# Initialization of w
#--------------------
w = randn(l_w)
# MSE solution (min||w'.data-symb||)
#-----------------------------------
w_mse = inv(Rx)*rxd
# LMS solution
#-------------
d = zeros(ns-l_w+1)
for n=l_w:ns
    Y_n = data[n:-1:n-l_w+1]
    w = w - ?*Y_n*(w'*Y_n - symb[n])
    d[n-l_w+1] = norm(w-w_mse)
end"
"# 6-7
plot(d, label=""?W_MSE?W_LMS?"")
title!(""The distance between the W_MSE and successsive W_LMS."")"
"S = LinRange(1.,40.,100)
min_dis = zeros(100)
for i in 1:100
    ? = exp(-S[i]*log(10)/20)
    noise = ?*randn(ns)
    data = Y + noise;
    Y_ = reshape(data[end:-1:1],(l_w, 1000))
    Rx = Y_*Y_'/1000
    ? = 1/(l_w * tr(Rx))
    rxd = Y_*symb[ns:-l_w:1]/1000
    w = randn(l_w)
    w_mse = inv(Rx)*rxd
    d = zeros(ns-l_w+1)
    for n=l_w:ns
        Y_n = data[n:-1:n-l_w+1]
        w = w - ?*Y_n*(w'*Y_n - symb[n])
        d[n-l_w+1] = norm(w-w_mse)
    end
    min_dis[i] = minimum(d)
end
plot(S, min_dis, xlabel=""SNR"", ylabel=""?W_MSE?W_LMS?"")
"
"# 8
# Equalizer design
# train data with ns = 10? and SNR = 20db
ns = 10000;
symb = rand((-1,1), ns)
h = [1,0.8,0.3]
h /= norm(h)
Y = [sum([symb[i+1-k]*h[k] for  k=1:min(3,i)]) for i=1:ns]
SNR = 20
? = exp(-SNR*log(10)/20)
noise = ?*randn(ns)
data = Y + noise;
l_w = 10
Y_ = reshape(data[end:-1:1],(l_w, 1000))
Rx = Y_*Y_'/1000
? = 1/(l_w * tr(Rx))
rxd = Y_*symb[ns:-l_w:1]/1000
w = randn(l_w)
w_mse = inv(Rx)*rxd
d = zeros(ns-l_w+1)
for n=l_w:ns
    Y_n = data[n:-1:n-l_w+1]
    w = w - ?*Y_n*(w'*Y_n - symb[n])
    d[n-l_w+1] = norm(w-w_mse)
end"
"# Data generation
#generate data for ????=10? symbols and ??????=15????. Observe the histogram of data. Whate do you note?
ns = 1000000;
symb = rand((-1,1), ns)
Y = [sum([symb[i+1-k]*h[k] for  k=1:min(3,i)]) for i=1:ns]
SNR = 15
# calcul of ? noise such that SNR = -40*ln(?)/ln(10)
? = exp(-SNR*log(10)/20)
noise = ?*randn(ns)
data = Y + noise;"
"# data histogram
using Distributions 
println(""Mean = $(mean(data))"")
println(""Variance = $(var(data))"")

histogram(data, label=""data"")"
"# deconvolution
S = [sum([data[i+1-k]*w[k] for  k=1:min(l_w,i)]) for i=1:ns]
print(""Pe without equalization = $(sum((abs.(S-symb)).>1)/ns)"")
# Dhistogram of equalizer outputs
histogram(S, label=""Deconvolution of data"")"
"function LMS(symb, lw, ?, SNR, h)
    """""" Implements LMS algorithm and returns the distance with the MSE approach at each iteration.
    """"""
    n? = length(symb)
    nh = length(h)
    filtered = [sum((1<=i-j+1<=n?) ? symb[i-j+1]*h[j] : 0 for j in 1:nh) for i in 1:n?]
    ? = exp(-SNR*log(10)/20)
    data = filtered + ?*randn(n?)
    nw = Int(n? / lw)
    Y = reshape(data[end:-1:1], (lw,nw))
    R? = Y * Y' / nw
    rxd = Y*symb[end:-lw:1] / nw
    w_MSE = inv(R?)*rxd
    w_LMS = randn(lw)
    e = []
    for i in lw:n?
        Yn = data[i:-1:i-lw+1]
        w_LMS = w_LMS - ?*Yn*(w_LMS'*Yn-symb[i])
        e = i==lw ? [norm(w_LMS-w_MSE)] : [e norm(w_LMS-w_MSE)]
    end

    return e'
end"
"n? = 10000
symb = rand([-1,1], n?)
def_lw = 10
def_SNR = 20
def_? = 0.01
def_h = [1,.8,.3]
def_h /= norm(def_h);
range_lw = [1,2,5,10,20,50]
plot()

for lw in range_lw
    e = LMS(symb, lw, def_?, def_SNR, def_h)
    plot!(e, label=""lw = $lw"", xlabel=""Iteration"", ylabel=""Error"")
end
title!(""||w_MSE-w_LSE||"")
plot!()"
"range_? = [0.001,0.01,0.1,0.15]

plot()

for ? in range_?
    e = LMS(symb, def_lw, ?, def_SNR, def_h)
    plot!(e, label=""? = $?"", xlabel=""Iteration"", ylabel=""Error"", yaxis=:log)
end

title!(""||w_MSE-w_LSE||"")
plot!()"
"range_SNR = [-10, 1, 10, 20, 50]

plot()

for SNR in range_SNR
    e = LMS(symb, def_lw, def_?, SNR, def_h)
    plot!(e, label=""SNR = $SNR"", xlabel=""Iteration"", ylabel=""Error"", yaxis=:log)
end

title!(""||w_MSE-w_LSE||"")
plot!()"
"nor = x -> x / norm(x)
range_h = [nor(rand(3)) for i in 1:5]

plot()

for h in range_h
    e = LMS(symb, def_lw, def_?, def_SNR, h)
    plot!(e, label=""h = $h"", xlabel=""Iteration"", ylabel=""Error"", yaxis=:log)
end

title!(""||w_MSE-w_LSE||"")
plot!()"
"f(x,y)   = ((x-2)*sin(y-1))^2 + x^2 + y^2
?f(x,y)  = [2*(x-2)*sin(y-1)^2 + 2*x, 2*sin(y-1)*cos(y-1)*(x-2)^2 + 2*y]
opt = [0.09172811859570773;0.7789586896619789]
println(""min f(x,y) = $(f(opt[1],opt[2]))"")
println(""optimum at (x*,y*) = ($(opt[1]),$(opt[2]))"")"
"# For options of Plots.jl, see https://docs.juliaplots.org/latest/
using Plots
pyplot()
X = -3:0.01:3
Y = -3:0.01:3
Z = [f(x,y) for x in X,y in Y]
plot(contourf(X, Y, Z), title=""f(x,y)"")
scatter!([opt[1]],[opt[2]], mode=""markers"", label=""min"")"
"# Gradient algorithm
# constant stepsize
#-------------------
using LinearAlgebra: norm
precision = 1.e-8
max_iter  = 10e4
init      = [-4, -2]
? = 0.01
# Constant stepsize
pt         = init
nb_const   = 0 # number of loops
resu_const = pt
while norm(pt-opt)>precision && nb_const<max_iter
    df = ?f(pt[1],pt[2])
    pt = [pt[1]-?*df[1], pt[2]-?*df[2]]
    resu_const  = [resu_const pt]
    nb_const += 1
end
resu_const"
"# Backtracking
#-------------
function backtracking(x,f,?f,d)
    """"""
    bactracking: 
    see e.g. https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf - p.464
    IN:
    ---
    x: initial point
    f, ?f: function to be minimized and its gradient
    d: searc direction
    OUT:
    ----
    y: final point
    n: number of loops
    """"""
    ? = rand(0:0.01:0.5)
    ? = rand(0:0.01:1)
    t = 1
    n = 0
    y  = x + t*d
    while f(y[1],y[2])  > f(x[1], x[2]) + ?*t*?f(x[1],x[2])'*d
        t *= ?
        y  = x + t*d
        n += 1
    end
    return y, n
end"
"# Gradient algorithm
# with backtracking
#-------------------

pt             = init
nb_iter_grad   = 0  # number of loops
nb_loops_grad  = 0  # number of inner loops count for backtracking
resu_grad      = pt

while norm(pt-opt)>precision && nb_iter_grad<max_iter
    pt, n_back     = backtracking(pt, f, ?f, -?f(pt[1],pt[2]))
    nb_loops_grad += n_back
    nb_iter_grad  += 1
    resu_grad      = [resu_grad pt]
end
resu_grad"
"println(""Error with constant stepsize: $(norm(resu_const[:,end]-opt))"")
println(""Number of iterations with constant stepsize: $nb_const\n\n"")
    
println(""Error with backtracking: $(norm(resu_grad[:,end]-opt))"")
println(""Number of iterations for backtracking= $nb_iter_grad"")
println(""Number of inner loops for backtracking = $nb_loops_grad"")"
"# Figure
X = -5:0.01:5
Y = -5:0.01:5
Z = [f(x,y) for x in X,y in Y]
plot(contourf(X, Y, Z))
scatter!([opt[1]],[opt[2]], mode=""markers"", label=""min"")
scatter!(resu_grad[1,:], resu_grad[2,:], label=""resu_grad"")
plot!(resu_const[1,:], resu_const[2,:], label=""resu_const"")"
"# Newton algorithm (with backtracking)
#-------------------------------------
?2f(x,y) = [2*sin(y-1)^2+2  4*sin(y-1)*cos(y-1)*(x-2); 
            4*(x-2)*sin(y-1)*cos(y-1)  2*(x-2)^2*(cos(y-1)^2-sin(y-1)^2)+2]

pt        = init
nb_iter   = 0        # number of loops
nb_loops  = 0        # number of inner loops count for backtracking
resu_N    = pt
while norm(pt-opt)>precision && nb_iter<max_iter
    pt, n_back = backtracking(pt, f, ?f, - inv(?2f(pt[1],pt[2]))*?f(pt[1],pt[2]))
    nb_loops  += n_back
    nb_iter   += 1
    resu_N = [resu_N pt]
end
resu_N"
"println(""Error with Newton+backtracking: $(norm(resu_N[:,end]-opt))"")
println(""Number of iterations for Newton= $nb_iter"")
println(""Number of inner loops for Newton = $nb_loops\n\n"")

println(""Error with backtracking: $(norm(resu_grad[:,end]-opt))"")
println(""Number of iterations for backtracking= $nb_iter_grad"")
println(""Number of inner loops for backtracking = $nb_loops_grad"")"
"using LinearAlgebra: eigvals
println(eigvals(?2f(pt[1],pt[2])))"
"# Figure: gradient and Newton with backtracking
plot(contourf(X, Y, Z))
scatter!([opt[1]],[opt[2]], mode=""markers"", label=""min"")
plot!(resu_grad[1,:], resu_grad[2,:], label=""resu_grad"")
plot!(resu_N[1,:], resu_N[2,:], label=""resu_N"")"
"A       = [1 0;0 5]
b       = [1,1]
p(x,y)  = (1/2)*[x,y]'*A*[x,y] - [x,y]'*b
?p(x,y) = A*[x,y] - b
opt     = inv(A)*b"
"precision = 1.e-8
max_iter  = 10e4
init      = [-2,3]

# optimal stepsize
pt            = init
nb_opt_grad   = 0 # number of loops
resu_opt_grad = pt

while norm(pt-opt)>precision && nb_opt_grad<max_iter
    pt, n_back     = backtracking(pt, p, ?p, -?p(pt[1],pt[2]))
    nb_opt_grad  += 1
    resu_opt_grad = [resu_opt_grad pt]
end
resu_opt_grad"
"println(""Error with gradient with optimal stepsize: $(norm(resu_opt_grad[:,end]-opt))"")
println(""Number of iterations = $nb_opt_grad"")"
"# For options of Plots.jl, see https://docs.juliaplots.org/latest/
using Plots
pyplot()
X = -5:0.01:5
Y = -5:0.01:5
P = [p(x,y) for x in X,y in Y]
plot(contourf(X, Y, P))
scatter!(resu_opt_grad[1,:], resu_opt_grad[2,:], label=""resu_opt_grad"")
scatter!([opt[1]],[opt[2]], mode=""markers"", label=""min"")"
"# Conjugate gradient
#--------------------
pt          = init
nb_iter_CG  = 0        # number of iterations
nb_loops_CG = 0        # number of inner loops count for backtracking
err_CG      = norm(pt-opt)
resu_CG = pt
# initialization
g = A*pt - b
d = -g
# iterations
for k = 1:2
    ?              = - g'*d / (d'*A*d)
    pt            += ?*d
    g              = A*pt - b
    ?              = g'*A*d / (d'*A*d)
    d              = -g + ?*d
    nb_opt_grad   += 1
    err_CG = [err_CG norm(pt-opt)]
    resu_CG = [resu_CG pt]
end"
"println(""Error with CG: $(err_CG[end])"")
println(""Error number of iterations with CG: $(size(resu_CG)[2])"")"
"# Figure: gradient with optimal step
X = -5:0.01:5
Y = -5:0.01:5
Z = [p(x,y) for x in X,y in Y]
plot(contourf(X, Y, Z))
scatter!(resu_CG[1,:], resu_CG[2,:], label=""resu_CG"")
scatter!([opt[1]],[opt[2]], mode=""markers"", label=""min"")"
"using LinearAlgebra: cond, diagm

function err_(n, A)
    println(cond(A))
    b = randn(n)
    p(X)  = (1/2)*X'*A*X - X'*b
    ?p(X) = A*X - b
    opt     = inv(A)*b

    pt          = randn(n)
    err_CG      = norm(pt.-opt)

    # initialization
    g = A*pt - b
    d = -g

    # iterations
    for k = 1:n
        ?              = - g'*d / (d'*A*d)
        pt            += ?*d
        g              = A*pt - b
        ?              = g'*A*d / (d'*A*d)
        d              = -g + ?*d
        err_CG = [err_CG;norm(pt.-opt)]
    end
    return err_CG, opt
end
pyplot(size=(1000,1600))
A1 = randn(10,10)
A_a1 = A1'*A1 + diagm(0=>ones(10))

A2 = randn(100,100)
A_a2 = A2'*A2 + diagm(0=>ones(100))

err_CG1, opt1 = err_(10, A_a1)
err_CG2, opt2 = err_(100, A_a2)

err_CG3, opt3 = err_(10, A1'*A1)
err_CG4, opt4 = err_(100, A2'*A2)

fig1 = plot(err_CG1/norm(opt1),yscale=:log10,label=""error norm of CG"",size=(1200,300), title=""error with CG for n = 10 adding diagm(0=>ones(n))"")
fig2 = plot(err_CG2/norm(opt2),yscale=:log10,label=""error norm of CG"",size=(1200,300), title = ""error with CG for n = 100 adding diagm(0=>ones(n))"")
fig3 = plot(err_CG3/norm(opt3),yscale=:log10,label=""error norm of CG"",size=(1200,300), title=""error with CG for n = 10 removing diagm(0=>ones(n))"")
fig4 = plot(err_CG4/norm(opt4),yscale=:log10,label=""error norm of CG"",size=(1200,300), title = ""error with CG for n = 100 removing diagm(0=>ones(n))"")
plot(fig1, fig2, fig3, fig4)"
"# Polak-Ribire
#---------------
pt          = [-4,-2]
opt = [0.09172811859570773;0.7789586896619789]
nb_iter_PR  = 0        # number of iterations
nb_loops_PR = 0        # number of inner loops count for backtracking
resu_PR     = pt

# initialization
d = -?f(pt[1],pt[2])
pt, n_back = backtracking(pt,f,?f,d)
nb_loops_PR += n_back
resu_PR = [resu_PR pt]
# iterations

while norm(pt-opt)>precision && nb_iter_PR<max_iter
    x = resu_PR[end-1,:]
    ? = ?f(pt[1], pt[2])'*(?f(pt[1], pt[2])- ?f(x[1], x[2]))/(?f(x[1],x[2])'*?f(x[1], x[2]))
    d = -?f(pt[1], pt[2]) + ?*d
    pt, n_back= backtracking(pt,f,?f,d)
    nb_loops_PR += n_back
    nb_iter_PR += 1
    resu_PR = [resu_PR pt]
end
resu_PR"
"println(""Error with gradient = $(norm(resu_grad[:,end]-opt))"")
println(""Number of iterations = $nb_iter_grad"")
println(""Number of inner loops = $nb_loops_grad\n"")

println(""Error with Polack-Ribire = $(norm(resu_PR[:,end]-opt))"")
println(""Number of iterations = $nb_iter_PR"")
println(""Number of inner loops = $nb_loops_PR"")"
"#Figure: Gradient and Polack-Ribire (with backtraking)
pyplot(size=(700,500))
plot(contourf(X, Y, Z))
scatter!([opt[1]],[opt[2]], mode=""markers"", label=""min"")
plot!(resu_grad[1,:], resu_grad[2,:], label=""resu_grad"")
plot!(resu_PR[1,:], resu_PR[2,:], label=""resu_PR"")"
"import Pkg
Pkg.add(""SpecialFunctions"")
Pkg.add(""SymPy"")
Pkg.add(""DualNumbers"") # https://github.com/JuliaDiff/DualNumbers.jl
Pkg.add(""ForwardDiff"") # https://github.com/JuliaDiff/ForwardDiff.jl
Pkg.add(""ReverseDiff"") # https://github.com/JuliaDiff/DualNumbers.jl"
"using Plots
pyplot()

f(x)     = x*(1-x)*(1-2x)^2*(1-8x+8x^2)^2*exp(1+exp(x)) 
df(x)    = f(x) * (1/x - 1/(1-x) - 4/(1-2x) + 2*(16x-8)/(1-8x+8x^2) + exp(x))
?f(x,?)  = (f(x+?)-f(x))/?
?fs(x,?) = (f(x+?)-f(x-?))/(2?)
h        = [10^(-k) for k in 16:-.5:1]
x        = .3
?1       = [abs(?f(x,?)-df(x)) for ? in h]
?2       = [abs(?fs(x,?)-df(x)) for ? in h]

plot(h,?1,xscale=:log10, yscale=:log10,label=""error forward"", 
               xlabel=""?"",ylabel=""|?f(x0,?)-f'(x0)|"")
plot!(h,?2,xscale=:log10, yscale=:log10,label=""error symmetric"")"
"using SymPy

@vars x
df_x = diff(f(x),x,1)
df_x"
"?fi(x,?)  = imag(f(x+?*im)/?)  # = imag((f(x+?*im)-f(x))/?)
?fis(x,?) = imag((f(x+?*im)-f(x-?*im))/(2?))

h       = [1/10^k for k in 20:-.5:3]
x       = .3
?1      = [abs(?f(x,?)-df(x))+1.e-25 for ? in h]
?2      = [abs(?fs(x,?)-df(x))+1.e-25 for ? in h]
?3      = [abs(?fi(x,?)-df(x))+1.e-25 for ? in h]
?4      = [abs(?fis(x,?)-df(x))+1.e-25 for ? in h]

plot(h,?1,xscale=:log10,yscale=:log10, label=""error forward"",
               xlabel=""?"",ylabel=""|?f(x0,?)-f'(x0)|"")
plot!(h,?2,xscale=:log10, yscale=:log10,label=""error symmetric"")
plot!(h,?3,xscale=:log10,yscale=:log10,label=""error forward complex"")
plot!(h,?4,xscale=:log10,yscale=:log10,label=""error symmetric complex"")"
"using DualNumbers

f(x)  = x*(1-x)*(1-2x)^2*(1-8x+8x^2)^2*exp(1+exp(x)) 
df(x) = f(x)*(1/x-1/(1-x)-4/(1-2x)+2*(16x-8)/(1-8x+8x^2)+exp(x))

x = .3
y = x+?
? = 1.e-6 # optimal step size for this function and symmetric difference
print(
""f($y) = $(f(y)) \n
error with dual numbers: $(df(x)-dualpart(f(y))) \n
error on finite difference: $( (f(x+?)-f(x-?))/(2?)-df(x))"" )"
"using ForwardDiff

f(x)  = x*(1-x)*(1-2x)^2*(1-8x+8x^2)^2*exp(1+exp(x)) 
df(x) = f(x)*(1/x-1/(1-x)-4/(1-2x)+2*(16x-8)/(1-8x+8x^2)+exp(x))

x = .3
print(""df(x) - ForwardDiff.derivative(f,x) 
      = $( df(x) - ForwardDiff.derivative(f,x) )"")"
"f(x)  = x[1]*?log(x[1]/sin(x[2]^2))
?f(x) = [?log(x[1]/sin(x[2]^2)) + 1/(2*?log(x[1]/sin(x[2]^2))),
         -x[1]*x[2]*cot(x[2]^2)*1/?log(x[1]/sin(x[2]^2))]

x      = [1,1]
@show ForwardDiff.gradient(f,x)
@show ?f(x);"
"using ForwardDiff, ReverseDiff

f(x)    = x[1]*?log(x[1]/sin(x[2]^2))
?f_1(x) = ?log(x[1]/sin(x[2]^2)) + 1/(2*?log(x[1]/sin(x[2]^2)))
?f_2(x) = -x[1]*x[2]*cot(x[2]^2)*1/?log(x[1]/sin(x[2]^2))

x      = [1.,1.]
@time println(""ForwardDiff.gradient error: $(ForwardDiff.gradient(f,x)-[?f_1(x),?f_2(x)])"")
@time println(""ReverseDiff.gradient error: $(ReverseDiff.gradient(f,x)-[?f_1(x),?f_2(x)])"") # note : woud not work with x=[1,1]"
"# Code from https://github.com/JuliaDiff/ReverseDiff.jl/blob/master/examples/gradient.jl
################
using ReverseDiff: GradientTape, GradientConfig, gradient, gradient!, compile, DiffResults

#########
# setup #
#########

# objective function; a and b are matrices
f(a, b) = sum(a' * b + a * b')

# pre-record a GradientTape for `f` using inputs of shape 100x100
const f_tape = GradientTape(f, (rand(100, 100), rand(100, 100)))

# compile `f_tape` into a more optimized representation
const compiled_f_tape = compile(f_tape)

# some inputs and work buffers to play around with
a, b = rand(100, 100), rand(100, 100)
inputs = (a, b)
results = (similar(a), similar(b))
all_results = map(DiffResults.GradientResult, results)
cfg = GradientConfig(inputs)

####################
# taking gradients #
####################

# with pre-recorded/compiled tapes (generated in the setup above) #
#-----------------------------------------------------------------#

# this should be the fastest method, and non-allocating
gradient!(results, compiled_f_tape, inputs)

# the same as the above, but in addition to calculating the gradients, the value `f(a, b)`
# is loaded into the the provided `DiffResult` instances (see DiffResults.jl documentation).
gradient!(all_results, compiled_f_tape, inputs)

# this should be the second fastest method, and also non-allocating
gradient!(results, f_tape, inputs)

# you can also make your own function if you want to abstract away the tape
?f!(results, inputs) = gradient!(results, compiled_f_tape, inputs)

# with a pre-allocated GradientConfig #
#-------------------------------------#
# these methods are more flexible than a pre-recorded tape, but can be
# wasteful since the tape will be re-recorded for every call.

gradient!(results, f, inputs, cfg)

gradient(f, inputs, cfg)

# without a pre-allocated GradientConfig #
#----------------------------------------#
# convenient, but pretty wasteful since it has to allocate the GradientConfig itself

gradient!(results, f, inputs)

gradient(f, inputs)"
"# Dual structure and associated operators

struct Dual_ <: Number # class of dual numbers 
    d::Tuple{Float64,Float64}
end

import Base: +, -, *, /, convert, promote_rule, show

+(x::Dual_,y::Dual_) = Dual_(x.d .+ y.d)
-(x::Dual_,y::Dual_) = Dual_(x.d .- y.d)
-(x::Dual_)          = Dual_((-x.d[1],-x.d[2]))
*(x::Dual_,y::Dual_) = Dual_((x.d[1]*y.d[1], x.d[2]*y.d[1]+x.d[1]*y.d[2]))
/(x::Dual_,y::Dual_) = Dual_((x.d[1]/y.d[1], (x.d[2]*y.d[1]-x.d[1]*y.d[2])/y.d[1]^2))

?                   = Dual_((0,1))
realPart(x::Dual_)  = x.d[1]
dualPart(x::Dual_)  = x.d[2]
conj(x::Dual_)      = Dual_((x.d[1],-x.d[2]))

convert(::Type{Dual_},x::Real) = Dual_((x,zero(x)))
promote_rule(::Type{Dual_},::Type{<:Number}) = Dual_
show(io::IO,x::Dual_)= x.d[2]>=0 ? print(io,x.d[1],""+?"",x.d[2]) : print(io,x.d[1],""-?"",abs(x.d[2]))"
"x=Dual_((1,2))
y=Dual_((3,4))
x+y, x/y, Dual_((1.,0))==1., Dual_((1,-2)), Dual_((0,0))^2"
"# let us redefine a few classic functions from basic operators

#cos_(x) = sum([(-x^2)^k/factorial(2k) for k=0:10])     # Poor definition !
#sin_(x) = sum([x*(-x^2)^k/factorial(2k+1) for k=0:9])

exp_(x;n=20) = 1 + sum( accumulate((u,v)->x*u/v, 1:n, init=1) )
cos_(x;n=20) = 1 + sum( accumulate((u,v)-> -x^2*u/(2v*(2v-1)), 1:n, init=1) )
sin_(x;n=20) = x + sum( accumulate((u,v)-> -x^2*u/(2v*(2v+1)), 1:n, init=x) )

@show exp_(1)-exp(1)
@show cos_(?/4)-?2/2 
@show sin_(?/4)-?2/2

function root_(x,k::Int;n=10)
    t=1
    for _=1:n
        t += (x/t^(k-1)-t)/k
    end
    t
end"
"using Plots
pyplot()

x = range(0,stop=10,length=100)
y = [sin_(rem(u,2?)+?) for u in x]

p1 = plot(x,realPart.(y),label=""sin_"")
p2 = plot(x,dualPart.(y),label=""sin_'"")
plot(p1,p2)#,layout=(1,1))
x = range(0,stop=10,length=20)
scatter!(x,[sin.(x),cos.(x)],label="""")"
"# Figure
using Plots
x = collect(range(-5, stop = 5 , length = 500))
y = collect(range(-15, stop = 15 , length = 500))
f(x,y) = (1-x)^2+100(y-x^2)^2
p = contour!(x,y,(x,y)->f(x,y))
y = 1 .- 3 .* x
p = plot!(x,y , color = ""red"")"
"using Plots
t = collect(range(0,2*?,length = 200))
x = collect(range(-2, stop = 2 , length = 500))
y = collect(range(-2, stop = 5 , length = 500))
f(x,y) = (1-x)^2+100(y-x^2)^2
contour(x,y,(x,y)->f(x,y))
plot!(  -1 .+ cos.(t) , 3 .+ sin.(t)      )"
"f(x,y)   = (1-x)^2+100(y-x^2)^2
?f(x,y)  = [-2 * (1-x)-400*x*(y-x^2) ; 200 * (y-x^2) ]
?2f(x,y) = [2-400*((y-x^2)-2*x^2) -400*x ; -400*x 200]

h(x,y)  = 3*x+y-1
?h      = [3;1]"
"# Backtracking
#-------------
function backtracking(x,f,?f,d)
    """"""
    bactracking: 
    see e.g. https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf - p.464
    IN:
    ---
    x: initial point
    f, ?f: function to be minimized and its gradient
    d: searc direction
    OUT:
    ----
    y: final point
    n: number of loops
    """"""
    ?,? = 0.25, 0.7 # backtracking parameters
    x_init = x
    ? = 1
    n=0
    while f(x[1],x[2])+(?*?).*(d'*?f(x[1],x[2])) - f(x[1]+?*d[1],x[2]+?*d[2]) < 0  
        n+=1
        ?  = ?*?
    end
    y = x+?*d 
    return y , n
end"
"prec        = 1.e-8
init        = [1,5]
pt          = init
nb_iter_N   = 0  # number of loops
nb_loops_N  = 0  # number of inner loops count for backtracking
resu_N      = pt
A = [3;1]
b = 1

while true
    nb_iter_N +=1

    ? = ?f(pt[1],pt[2])
    
    M = [?2f(pt[1],pt[2])  A ;A' [0]]

    V = [-? ; b - A' * pt]

    reslt = inv(M)*V
    d = [reslt[1];reslt[2]]

    if (-?'*d)/2 < prec  # ?f(x+td)_{t=0}= ?'*d
        break
    end
    pt,n_inner =backtracking(pt,f,?f,d)
    nb_loops_N+=n_inner

    resu_N      = [resu_N pt]
end"
"println(""Number of iterations for constrained Newton = $nb_iter_N"")
println(""Number of inner loops for constrained Newton = $nb_loops_N"")"
"# Figure
x = collect(range(-2, stop = 2 , length = 500))
y = collect(range(-2.5, stop = 10 , length = 500))
contourf(x,y ,(x,y)->f(x,y))
Plots.plot!(resu_N[1,:],resu_N[2,:], label=""Linearly Constrained Newton"")
Plots.plot!(x, x -> 1 - 3 .* x ,color = :blue,label=""Contrainte d'galit"")
scatter!([1],[5], color=:green,label=""Point de dpart"")
scatter!([resu_N[1,end]], [resu_N[2,end]], color=:yellow,label=""Point d'arrive"")
plot!(title = "" Algorithme de Newton sous contrainte"")
"
"using LinearAlgebra: norm

prec        = 1.e-12
init        = [-1,3]  # center of the circle
pt          = init
nb_iter_IP  = 0  # number of loops
nb_loops_IP = 0  # number of inner loops count for backtracking
resu_IP     = pt

x,y  = (pt[1],pt[2])


g(x,y) = 1 - (x + 1)^2 + (y - 3)^2 

?g(x,y) = [2*(x+1) ; 2*(y-3)]
?2g(x,y) = [2 0;0 2]


?(x,y) = - log(g(x,y))
??(x,y) = - ?g(x,y)./g(x,y)
?2?(x,y) = -?2g(x,y)./g(x,y) .+ ??(x,y).^2  



t = 20
? = 1.5
?= 15
"
"
while true
    nb_iter_IP += 1 
    ?(t,pt) = t * f(pt[1],pt[2]) + ?(pt[1],pt[2])
    ??(t,pt) = t * ?f(pt[1],pt[2]) + ??(pt[1],pt[2])
    ?2?(t,pt) = t * ?2f(pt[1],pt[2]) + ?2?(pt[1],pt[2])
    for k=1:? # inner loop
        d = -inv(?2?(t,pt))*??(t,pt)
        while norm(pt+d-init)>1
            d = 0.5*d
        end
        pt, n_loop = backtracking(pt,f,?f,d)
        nb_loops_IP+= n_loop
    end
    resu_IP = [resu_IP pt]
    if 1/t < prec
        break
    end
    resu_IP = [resu_IP pt]
    t = ?*t
end"
"println(""Number of iterations for Interior point = $nb_iter_IP"")
println(""Number of inner loops for  Interior point = $nb_loops_IP"")"
"# Figure
using Plots
t = collect(range(0,2*?,length = 200))
x = collect(range(-2, stop = 2 , length = 500))
y = collect(range(-2, stop = 5 , length = 500))
f(x,y) = (1-x)^2+100(y-x^2)^2
contourf(x,y, (x,y) -> f(x,y))
plot!(-1 .+ cos.(t), 3 .+ sin.(t), label=""Constraint"")
scatter!(resu_IP[1,:],resu_IP[2,:],color=:yellow, label=""IP Method"")"
"# Basic operations
a = 10
b = 5
y = a + b
print(a, ""+"",b,""="",y)
z = exp(a)"
"round(1.7), floor(1.9), ceil(1.9), trunc(-1.6)"
"gcd(2*3*5*7*11, 3*7*13), lcm(2*2*3, 2*5) # greatest common divisor, lowest common multiplier"
"# Basic operations on vectors and matrices
A = rand(10,5)
z = rand(5,1)
y = A*z
sum(y)"
"using LinearAlgebra
A = rand(10,10)
print(det(A), "" "", tr(A))
eigen(A)"
"using Plots
?Plots.plot"
"typeof(?), typeof(3/5),typeof(3//5), typeof('a'),typeof(""a""), typeof(Float64)"
"supertype(Real), supertype(Number)"
subtypes(Real)
"Real <: Number, Signed <: Number, Integer <: Unsigned"
"typeof(1), Int"
"x,y = 3, 4.2
typeof(x), typeof(y), x+y, typeof(x+y)"
"round(x+y),convert(Int64,round(x+y)), round(Int64,x+y)"
"promote(2.1,im), promote([1,2], [3.,4])"
"1:10, 0:5:25, range(0,step=5, length=6)"
"a= [1 2 3]
b= [1,2,3]
c= [1;2;3]"
"typeof(a),length(a)"
"a = [1,2,3]
b=[0,0]
c=append!(a,b)
a,b,c"
?append
"D = zeros(5,5)
E = ones(5,1)
F = rand(4,8)*10
F"
"size(F),size(F,1),length(F)"
?reshape
"sum(F,dims=1),sum(F), minimum(F,dims=1)"
exp.(F)
F .+ 5
"J = [1 2 5 4 9]
I = J
I[4] = 0
print(I, ""\n"",J)"
"J = [1 2 5 4 9]
I = copy(J)
I[4] = 0
print(I, ""\n"",J)"
"x = 4
y = 3
if x < y
    println(""$x is less than $y"")
elseif x > y
    println(""$x is greater than $y"")
else
    println(""$x is equal to $y"")
end"
"x,n = 0,0
while x<100
    n+=1
    x+=rand()
end
x,n"
"y = 2
for j = 1:5
    y = y*y
    print(y,"", "")
end"
"# Function definition
function f(a,b)
    y = exp(-a) + exp(-b)
    return y
end"
"f(5,5)"
"# It is possible to specify the types
function g(a::Int,b::Int)
    z = rem(a+b,2)
    return z
end"
"g(0.5,2)"
"g(128,255)"
?rem
"function my_function(v1::Array{Float64,1},v2)
    U = zeros(length(v1))
    for j=1:length(v1)
        U[j] = v1[j] + v2
    end
    return U
end 
my_function(rand(5),4)"
"# We may also check for inconsistancy in parameters
function my_function2(v1::Array{Float64,1},v2::Array{Float64,1})
    if(length(v1) != length(v2))
        error(""v1 and v2 must have the same dimension"")
    end
    U = exp.(v1) + exp.(v2)
    return U
end"
"using Plots
x = rand(10)
y = 6*x .+ 3
p1 = Plots.plot(x,y) # Make a line plot"
"y = rand(10)
p2 = scatter(x,y) # Make a scatter plot <=> plot(x,y,seriestype=:scatter,title=""My Scatter Plot"")"
"Plots.plot(x,y,xlabel=""This one is labelled"",lw=3,title=""Title"",legend=false)"
"x = 1:10
y = 5*x.^2 + 3*x .+ 2 
z = exp.(x/1.5)
Plots.plot(x,y,label=""Polynomial function"")
Plots.plot!(x,z,label=""Exponential function"")"
"using Plots

function move!(P;?=.01randn(2))
    P = [P P[:,end]+?]
    return P
end
P = [1.,2]
for k=1:10^4
    P=move!(P)
end
fig = plot()
fig = plot!(P[1,:],P[2,:],label=""trajectory"",color=:blue)
fig = scatter!([P[1,1]],[P[2,1]],markershape=:circle,label=""origin"")
fig = scatter!([P[1,end]],[P[2,end]],markershape=:circle,color=:green,
               label=""end"",legend=:outertopright,size=(500,300))"
"using Distributions

?,?   = (2,4)
d     = Beta(?,?)
n     = 10^3
data  = rand(d,n);"
"println(""$(?1), $(?2)"")
println(""$(mean(data)), $(var(data))"")"
"using Plots, StatsPlots

histogram(data,bins=:scott,normed=true,size=(300,200),label=""histogram"")
plot!(d,lw=3,label=""pdf"")"
"?1_est = mean(data)
?2_est = mean(data.^2)-?1_est^2
c      = (1-?1_est)/?1_est
?_est  = (?1_est^2*c-?2_est)/(?2_est*(1+c))
?_est  = ?_est*c
@show ?_est
@show ?_est"
"d_est = Beta(?_est,?_est)
plot(d,label=""True distribution"")
plot!(d_est,label=""Estimated distribution"",size=(300,200))"
"# filter    
using LinearAlgebra: norm

L  = 10
h = 1 ./ ((1:L+1).^3)
h = h/norm(h);

# plots of impulse and frequency response
using Plots
pyplot()

p1     = plot(0:L,h,xlabel=""t"",label=""Impulse response"")
nb_pts = 100
freq   = collect(0:1/(2*nb_pts):1/2)
F      = 1/sqrt(L)*exp.((-im.*freq)*collect(0:L)') # Fourier transform matrix
p2     = plot(freq,abs.(F*h),xlabel=""f"", label=""Frequency response"")

plot(p1,p2,layout=(1,2))"
"function generate_data(h=h, n=100,SNR=1000)
    # model y = Mx+w
    # generation of x
    x = sign.(rand(n) .- .5);
    # generation of M
    L = length(h)-1
    M = zeros(n+L,n)
    for k=1:n
        M[k:k+L,k] = h
    end
    # observed data generation for n symbols transmitted 
    ?   = 10^(-SNR/20)
    y   = M*x+?*randn(n+L)
    return M,x,y
end"
"function x_MMSE(M,y)
    # MMSE solution
    A     = M'*M
    b     = M'*y
    x_est = inv(A)*b
end"
"MSE(x,x_est)    = norm(x-x_est)/norm(x)
nb_err(x,x_est) = Int(sum(abs.(x-sign.(x_est)))/2)

M,x,y  = generate_data()  
x_est  = x_MMSE(M,y)
MSE(x,x_est), nb_err(x,x_est)"
"function MSE_BER(n)
    v_SNR    = [0,5,10,15,20]
    nb_SNR   = length(v_SNR)
    v_MSE    = zeros(nb_SNR)
    v_nb_err = zeros(nb_SNR)

    for k in 1:nb_SNR
        M,x,y       = generate_data(h,n,v_SNR[k])
        x_est       = x_MMSE(M,y)
        v_MSE[k]    = MSE(x,x_est)
        v_nb_err[k] = nb_err(x,x_est)
    end
    v_SNR,v_MSE,v_nb_err
end"
"MSE_BER(10^5)

p1 = plot(v_SNR,v_MSE,ylabel=""MSE"",xlabel=""SNR"",label="""")
p2 = plot(v_SNR,v_nb_err/length(v_nb_err).+1.e-100, yscale=:log10, ylabel=""error rate"",xlabel=""SNR"",label="""")
plot(p1,p2,layout=(1,2))"
"#using Pkg
#Pkg.add(""Images"")
#Pkg.add(""MAT"")

using MAT
using Plots
using Images


pyplot()

file = matopen(""project_data.mat"")
img = read(file, ""im"")
sources = read(file,""sources"")
rgb = read(file,""rgb"")
close(file)"
"using Distributed
CPU_CORES = 4 

addprocs(7)
nprocs()"
nworkers()
"# visualize data in rgb (using bands 67,109,141 as th RGB channels)
p1 = colorview(RGB,permutedims(rgb,(3,1,2))) # convert 3d array to the image format used by julia"
"#visualize a spectral band on its own
p2 = heatmap(img[:,:,150],aspect_ratio=1, yflip = true,c=:ice)"
"# visualize the endmembers to be used

plot(sources[:,1],label = ""gravel"")
plot!(sources[:,2],label = ""grass"")
plot!(sources[:,3],label = ""soil"")
plot!(sources[:,4],label = ""trees"")
xlabel!(""Spectral band"")
ylabel!(""Reflectance value"")"
"function getdims(img,sources)
    L = size(img,3)
    N = size(img,1)*size(img,2)
    P = size(sources,2)
    return N,L,P
end"
"function initiate(img , sources)
    N,L,P = getdims(img,sources);
    X = transpose(reshape(img,(N,L)));
    S = sources;
    A = ones(P,N)/P;
    return X,S,A
end"
"using LinearAlgebra
using Statistics"
"img_small = img[1:100,1:100,:]; # use a small crop of the image first
img_origin = copy(img);

X1,S1,A1 = initiate(img_small,sources);
X2,S2,A2 = initiate(img_origin,sources);"
"f(X,S,A) = 0.5* norm(X-S*A,2)
?f(X,S,A) = -S'*(X - S * A)"
"size(?f(X1,S1,A1))"
"function projected_gradient_descent(X,S,A,f,?f,max_iter,eps)
    L = opnorm(S'*S) ; 
    ? = 2/L ;
    n_iter = 0;
    A_next = max.(0, (A - ? * ?f(X,S,A)));
    list_loss = [];
    while norm(A-A_next)> eps && n_iter < max_iter 
        n_iter+=1
        A = A_next
        A_next = max.(0, (A_next - ? * ?f(X,S,A_next) ))
        list_loss=[list_loss ; f(X,S,A_next)];
    end
return A_next, n_iter,list_loss

end"
"function parallelized_projected_gradient_descent(X, S, A, max_loops, f,?f,nb_workers, eps)
    block_size = floor(size(X,2)/nb_workers) # quantity of calculation for each parallelizable block
    workers = []
    num_total_iter = zeros(nb_workers) 
    sum_losses = zeros(max_loops)
    for i in 0:(nb_workers-1)
        
        j = Int(i*block_size+1)
        if i == nb_workers-1
            j_end = size(X,2)
        else
            j_end = Int((i+1)*block_size)
        end
        workers = [workers; @spawn projected_gradient_descent(X[:,j:j_end], S, A[:,j:j_end],f,?f, max_loops, eps)]
        A[:,j:j_end], nb_iters, loss = fetch(workers[i+1])
        num_total_iter[i+1] =  num_total_iter[i+1]+nb_iters
        sum_losses += loss
    end
    return A, num_total_iter, sum_losses
end"
"A_opt1,iter1,f1 = projected_gradient_descent(X1, S1, A1,f,?f, 300, 0.001);"
"plot(f1, title=""Projected Gradient descent on img_small, \n max_iters=300, precision=0.001"",label=""Serial Approach"")"
"losses=zeros(300,5);
for i = 0 : 4
    @time  A1_opt_w,n_iters_w,losses_w = parallelized_projected_gradient_descent(X1, S1, A1, 300, f,?f,nworkers()-i, 0.001);
    losses[:,i+1]= losses_w;
end"
"plot(losses[:,5], label=""3 workers"")
plot!(losses[:,4], label=""4 workers"")
plot!(losses[:,3],label=""5 workers"")
plot!(losses[:,2],label=""6 workers"")
plot!(losses[:,1], title=""Parallelized Approach with Projected Gradient descent on img_small, \n max_iters=300, precision=0.001"",label=""7 workers"")"
"losses=zeros(300,5);
for i = 0 : 4
    @time  A1_opt_w,n_iters_w,losses_w = parallelized_projected_gradient_descent(X1, S1, A1, 300, f,?f,nworkers()-i, 0.1);
    losses[:,i+1]= losses_w;
end"
"plot(losses[:,5], label=""3 workers"")
plot!(losses[:,4], label=""4 workers"")
plot!(losses[:,3],label=""5 workers"")
plot!(losses[:,2],label=""6 workers"")
plot(losses[:,1], title=""Parallelized Approach with Projected Gradient descent on img_small, \n max_iters=300, precision=0.1"",label=""7 workers"")"
"plot(losses_full, title=""Parallelized Approach with Projected Gradient descent , \n max_iters=500, precision=0.1 \n workers = 6"",label=""full_image"")"
"plot(losses_part, title=""Parallelized Approach with Projected Gradient descent , \n max_iters=500, precision=0.1 \n worker = 6"",label=""small_image"")"
"reconst_img = S2*A2_opt_w
img3 = reshape(reconst_img',(size(img_origin,1), size(img_origin,2), size(img_origin,3)))
p2 = heatmap(img3[:,:,150],aspect_ratio=1, yflip = true,c=:ice)"
"#--------------------------
# PART I : Kalman filter
#--------------------------

#--------------------------
# Trajectory Synthesis
#--------------------------

pyplot(size=(1300,500))

T = 200
f = 2/T
?_n = 1
?_v = 10^(-1)
? = 0.5
Id_4 = Matrix(I,4,4)

Mt = zeros(2,T)
St = zeros(2,T)

for t=1:T
    Mt[:,t] = sqrt(t)*[cos(2*?*f*t); sin(2*?*f*t)]
    if t>1
        St[:,t] = Mt[:,t] - Mt[:,t-1]
    end
end

St[:,1] = St[:,2]

d = MvNormal([0; 0; 0; 0],?_n^2*Id_4)
nt = rand(d,T)

Mt_noise = Mt + nt[1:2,:]
St_noise = St + nt[3:4,:]

fig_position = plot(Mt[1,:], Mt[2,:], title=""Position Trajectories"",xlabel=""x"",ylabel=""y"", labels=""Noiseless trajectory"",color=""red"")
plot!(Mt_noise[1,:], Mt_noise[2,:], labels=""Noisy trajectory"",color=""light blue"")

fig_speed = plot(St_noise[1,:], St_noise[2,:], title=""Speed Trajectories"",xlabel=""Vx"",ylabel=""Vy"", labels=""Noisy trajectory"",color=""light blue"")
plot!(St[1,:], St[2,:], labels=""Noiseless trajectory"",color=""red"")

plot(fig_position,fig_speed)"
"#--------------------------
# State Space Model
#--------------------------

Z = zeros(2,2)
F = [[I I Z] ; [Z I I] ; [Z Z ?*I]]
G = [Z ; Z ; I]
H = [[I Z Z] ; [Z I Z]]
U = Id_4

D_Q = G * G'
D_R = U * U'

Q = (?_v^2)*D_Q
R = (?_n^2)*D_R

display(D_Q), display(D_R)"
"#------------
# Observation
#------------

Yt = [Mt_noise ; St_noise]

display(Yt)"
"#--------
# Storage
#--------

X_filtered = zeros(6,T)
all_P_ = Dict()
all_P = Dict()"
"#----------
# Filtering
#----------

pyplot(size=(1300,500))

?_p = 0.1
P_ = (?_p^2)*Matrix(I,6,6) 
X_ = zeros(6,1) 


for t=1:T
    X = F*X_ 
    P = F*P_*F' + Q 
    K = P*H'*inv(H*P*H' + R)
    X_ = X + K*(Yt[:,t]-H*X)
    P_ = P - K*H*P
    X_filtered[:,t] = X_
    all_P_[t] = P_
    all_P[t] = P
end


fig_position_filter = plot(Mt_noise[1,:], Mt_noise[2,:], title=""Positions Trajectory"",xlabel=""x"",ylabel=""y"", labels=""Noisy trajectory"",color=""light blue"")
plot!(X_filtered[1,:], X_filtered[2,:], labels=""Filtered trajectory"",color=""green"")

fig_speed_filter = plot(St_noise[1,:], St_noise[2,:], title=""Speeds Trajectory"",xlabel=""Vx"",ylabel=""Vy"", labels=""Noisy trajectory"",color=""light blue"")
plot!(X_filtered[3,:], X_filtered[4,:], labels=""Filtered trajectory"", color=""green"")

plot(fig_position_filter, fig_speed_filter)"
"#---------------------------------------
#Checking of the robustness of the model
#---------------------------------------

# ?_n = 10 :

?_n_0 = 10
d_0 = MvNormal([0;0;0;0], ?_n_0^2*Id_4)
nt_0 = rand(d_0,T)


Mt_noise_0 = Mt + nt_0[1:2,:]
St_noise_0 = St + nt_0[3:4,:]


#Initialization

X_filtered_0 = zeros(6,T)
Yt_0 = [Mt_noise_0 ; St_noise_0]

P_0 = (?_p^2)*Matrix(I,6,6) 
X_0 = zeros(6,1)


#Kalman filter

for t=1:T
    X0 = F*X_0
    P0 = F*P_0*F' + Q
    K0 = P0*H'*inv(H*P0*H' + R)
    X_0 = X0 + K0*(Yt_0[:,t]-H*X0)
    P_0 = P0 - K0*H*P0
    X_filtered_0[:,t] = X_0
end"
"# ?_n = 0.1 :

?_n_1 = 0.1
d_1 = MvNormal([0;0;0;0], ?_n_1^2*Id_4)
nt_1 = rand(d_1,T)


Mt_noise_1 = Mt + nt_1[1:2,:]
St_noise_1 = St + nt_1[3:4,:]


#Initialization

X_filtered_1 = zeros(6,T)
Yt_1 = [Mt_noise_1 ; St_noise_1]

P_1 = (?_p^2)*Matrix(I,6,6) 
X_1 = zeros(6,1)


#Kalman filter

for t=1:T
    X1 = F*X_1
    P1 = F*P_1*F' + Q
    K1 = P1*H'*inv(H*P1*H' + R)
    X_1 = X1 + K1*(Yt_1[:,t]-H*X1)
    P_1 = P1 - K1*H*P1
    X_filtered_1[:,t] = X_1
end"
"#?_n = 0.001 :

?_n_2 = 0.001
d_2 = MvNormal([0;0;0;0], ?_n_2^2*Id_4)
nt_2 = rand(d_2,T)

Mt_noise_2 = Mt + nt_2[1:2,:]
St_noise_2 = St + nt_2[3:4,:]

#Initialization
X_filtered_2 = zeros(6,T)
Yt_2 = [Mt_noise_2 ; St_noise_2]

P_2 = (?_p^2)*Matrix(I,6,6) 
X_2 = zeros(6,1) 


#Kalman filter

for t=1:T
    X2 = F*X_2 
    P2 = F*P_2*F' + Q 
    K2 = P2*H'*inv(H*P2*H' + R)
    X_2 = X2 + K2*(Yt_2[:,t]-H*X2)
    P_2 = P2 - K2*H*P2
    X_filtered_2[:,t] = X_2
end"
"pyplot(size=(1300,500))

fig_position_filter_0 = plot(Mt_noise_0[1,:], Mt_noise_0[2,:], title=""Positions Trajectories with ?_n=10"",xlabel=""x"",ylabel=""y"", labels=""Noisy trajectory"",color=""light blue"")
plot!(X_filtered_0[1,:], X_filtered_0[2,:], labels=""Filtered trajectories"",color=""green"")

fig_speed_filter_0 = plot(St_noise_0[1,:], St_noise_0[2,:], title=""Speeds Trajectories with ?_n=10"",xlabel=""Vx"",ylabel=""Vy"", labels=""Noisy trajectory"",color=""light blue"")
plot!(X_filtered_0[3,:], X_filtered_0[4,:], labels=""Filtered trajectory"", color=""green"")

plot(fig_position_filter_0, fig_speed_filter_0)"
"pyplot(size=(1300,500))

fig_position_filter_1 = plot(Mt_noise_1[1,:], Mt_noise_1[2,:], title=""Positions Trajectories with ?_n=0.1"",xlabel=""x"",ylabel=""y"", labels=""Noisy trajectory"",color=""light blue"")
plot!(X_filtered_1[1,:], X_filtered_1[2,:], labels=""Filtered trajectories"",color=""green"")

fig_speed_filter_1 = plot(St_noise_1[1,:], St_noise_1[2,:], title=""Speeds Trajectories with ?_n=0.1"",xlabel=""Vx"",ylabel=""Vy"", labels=""Noisy trajectory"",color=""light blue"")
plot!(X_filtered_1[3,:], X_filtered_1[4,:], labels=""Filtered trajectory"", color=""green"")

plot(fig_position_filter_1, fig_speed_filter_1)"
"pyplot(size=(1300,500))

fig_position_filter_2 = plot(Mt_noise_2[1,:], Mt_noise_2[2,:], title=""Positions Trajectories with ?_n=0.001"",xlabel=""x"",ylabel=""y"", labels=""Noisy trajectory"",color=""light blue"")
plot!(X_filtered_2[1,:], X_filtered_2[2,:], labels=""Filtered trajectories"",color=""green"")

fig_speed_filter_2 = plot(St_noise_2[1,:], St_noise_2[2,:], title=""Speeds Trajectories with ?_n=0.001"",xlabel=""Vx"",ylabel=""Vy"", labels=""Noisy trajectory"",color=""light blue"")
plot!(X_filtered_2[3,:], X_filtered_2[4,:], labels=""Filtered trajectory"", color=""green"")

plot(fig_position_filter_2, fig_speed_filter_2)"
"#----------
# Smoothing
#----------

X_smoothed = zeros(6,T)
X_smoothed[:,T] = X_filtered[:,T] #?=0.1


for t=T-1:-1:1
    K_u = all_P_[t]*F'*inv(all_P[t+1])
    X_smoothed[:,t] = X_filtered[:,t] + K_u*(X_smoothed[:,t+1]-F*X_filtered[:,t])
end "
"#----------------
# Graphic outputs
#----------------

pyplot(size=(1300,500))

fig_position_smoothed = plot(X_filtered[1,:], X_filtered[2,:], title=""Positions Trajectory"",xlabel=""x"",ylabel=""y"", labels=""Filtered trajectory"",color=""green"")
plot!(X_smoothed[1,:], X_smoothed[2,:], labels=""Smoothed Trajectory"",color=""red"")

fig_speed_smoothed = plot(X_filtered[3,:], X_filtered[4,:], title=""Speeds Trajectory"",xlabel=""Vx"",ylabel=""Vy"", labels=""Filtered trajectory"",color=""green"")
plot!(X_smoothed[3,:], X_smoothed[4,:], labels=""Smoothed Trajectory"",color=""red"")

plot(fig_position_smoothed, fig_speed_smoothed)"
"pyplot(size=(1300,500))

fig_position_smoothed_1 = plot(Mt[1,:], Mt[2,:], title=""Positions Trajectory"",xlabel=""x"",ylabel=""y"", labels=""Noiseless trajectory"",color=""black"")
plot!(X_smoothed[1,:], X_smoothed[2,:], labels=""Smoothed trajectory"",color=""red"")

fig_speed_smoothed_1 = plot(St[1,:], St[2,:], title=""Speeds Trajectory"",xlabel=""Vx"",ylabel=""Vy"", labels=""Noiseless trajectory"",color=""black"")
plot!(X_smoothed[3,:], X_smoothed[4,:], labels=""Smoothed trajectory"",color=""red"")

plot(fig_position_smoothed_1, fig_speed_smoothed_1)"
"#-----------------------------
# 1) Data model and generation
#-----------------------------
T = 100
?_v = 0.1
?_w = 1
V = ?_v*randn(T)
W = ?_w*randn(T)
X = zeros(T)
Y = zeros(T)

for t=1:T-1
    Y[t] = 0.05*X[t]^2 + W[t]
    X[t+1] = 0.5*X[t] + 25*X[t]/(1+X[t]^2) + 8*cos(1.2*t) + V[t]
end

Y[T] = 0.05*X[T]^2 + W[T]


# Graphic outputs
#----------------

pyplot(size=(1300,500))

fig = plot(X, title=""Random Trajectory"",xlabel=""t"",ylabel=""Position"", label = ""X"", color=""red"")
plot!(Y, xlabel=""t"",ylabel=""Position"",label = ""Y"", color = ""green"")
plot(fig)"
"#--------------------------
# 2) Particle sampling
#--------------------------
# Particles initialization
#--------------------------

N = 10^3
#?_v = 0.1

Xt = ?_v*randn(N) 
W = (1/N)*ones(N) #Initialization of weights
Xt_sampled = zeros(N,T) #Storage of each x_t(i)
weights = zeros(N,T) #Storage of weights

#--------------------------
# Particles sampling
#--------------------------
for t=1:T
    
    #Step 1
    for n=1:N
        seed = Normal((Xt[n]*0.5 + 25*Xt[n]/(1+Xt[n]^2)+8*cos(1.2*t-1)), ?_v)
        sample = rand(seed,1)
        Xt[n] = sample[1]
    end

    #Step 2
    Xt_sampled[:,t] = Xt

    #Step 3
    for n=1:N
        p_yx = (1/?(2?))*exp(-0.5*(Y[t]-0.05*Xt[n]^2)^2)
        W[n] = p_yx*W[n]
        weights[n,t] = p_yx*W[n]
    end

    sum_w = sum(weights[:,t])
    W = (1/sum_w)*W
    weights = (1/sum_w)*weights
    
    #Step 4
    N_eff = 1/sum((weights[:,t].^2))

    if N_eff < 0.9*N
        multi_seed = Multinomial(N-1,weights[:,t])
        indexes = rand(multi_seed, N)
        for n=1:N
            Xt[n] = Xt_sampled[indexes[n]+1,t]
        end
        Xt_sampled[:,t] = Xt
        W = (1/N)*ones(N)
        weights[:,t] = (1/N)*ones(N)
    end
end

X_plot = zeros(T)
for t=1:T
    X_plot[t] = mean(Xt_sampled[:,t])
end


#--------------------------
# Graphic output
#--------------------------

pyplot(size=(1300,500))

fig_filter = plot(X_plot,title=""Trajectory of X obtained by filtering and real X"", xlabel=""t"", ylabel=""Xt"",labels=""X filtered"",color=""blue"")
plot!(X, labels=""Real X"", color=""red"")
plot(fig_filter)"
"# 1
function gauss_pdf(x;m=0.,?2=1.)
    return 1/sqrt(2 * ? * ?2) * exp( - ( (m - x)^2 ) / (2 * ?2) )
end"
"# test
x = range(-10,stop=10,length=100)
f = gauss_pdf.(x;m=0.,?2=2.)
plot(x,f,size=(300,300),label="""")"
"# 2
struct Brownian
    ?::Float64        
    Tmin::Float64      
    Tmax::Float64      
    B0::Float64       
    ?2::Float64        
end"
"brownian_instance = Brownian(0.01, 0.0, 1.0, 0.0, 0.1)
println(""?: "", brownian_instance.?)
println(""Tmin: "", brownian_instance.Tmin)
println(""Tmax: "", brownian_instance.Tmax)
println(""B0: "", brownian_instance.B0)
println(""?2: "", brownian_instance.?2)"
"#test
B = Brownian(.01,0.,1.,0.,1.)
B.?,B.Tmin,B.Tmax,B.B0,B.?2 "
using LaTeXStrings
"function sample(B::Brownian)
    # Generates a trajectories of the brownian motion B
    # returns a trajectory on [B.Tmin,B.Tmax]
    
    num_steps = Int(round((B.Tmax - B.Tmin) / B.?))
    trajectory = zeros(num_steps + 1)
    trajectory[1] = B.B0
    
    for i in 2:(num_steps + 1)
        ?B = sqrt(B.?) * B.?2 * randn()
        trajectory[i] = trajectory[i-1] + ?B
    end
    
    return trajectory
    
end"
"function draw(B::Brownian ; nb_traj=100,enveloppe=true)
    # Plots trajectories of the brownian motion
    # nb_traj: number of trajectories to be plot
    # enveloppe: plots the enveloppe at B0+(+/-)3std
    plot()
    figure_size = (800, 400)
    for i in 1:nb_traj 
        trajectory = sample(B)
        plot!(trajectory, size=figure_size)
    end
    plot!(legend=false)
    
    t = range(B.Tmin,stop=B.Tmax,length=Int((B.Tmax - B.Tmin) / B.?))
    upper_bound = B.B0 .+ 3 * sqrt.(B.?2 .* t)
    lower_bound = B.B0 .- 3 * sqrt.(B.?2 .* t)
    plot!([upper_bound], color = ""red"", linestyle =:dash)
    plot!([lower_bound], color = ""blue"", linestyle =:dash)
end"
"#test
draw(B;nb_traj=10^3)"
"function hist(B ; nb_traj=1000, t= :Nan)
    # Plots the histogram at t from nb_traj trajectories
    # of the Brownian motion together with the
    # theoretical distribution
    plot()
    figure_size = (800, 400)
    trajectories = []
    for i in 1:nb_traj 
        trajectory = sample(B)
        push!(trajectories, trajectory)
    end
    
    t_index = round(Int, t * length(trajectories[1]))

    histo = [x[t_index] for x in trajectories]
    histogram(histo, label = ""Distribution of the trajectories at t=$t"" )
end"
"# 3
hist(B ; nb_traj=10^4, t=.5)"
"# 4

# Black-Scholes model
# Equation dX_t = rX_tdt + aX_tdB_t, with r=-1 et a=1
#----------------------------------------------------
r, ?, X0  = -1.0,1.0,10.




function black_scholes_trajectory(t,Bt;r=-1.,a=1.,X0=1.)
    # returns sampling instants and samples
    # of a Black-holes trajectory
    # t:  sampling instants
    # Bt: brownian motion trajectory
    # r:  drift coefficient
    # a:  diffusion coefficient 
    # X0: initial value
    # Bt:  input brownian motion trajectory
    
    Xt = zeros(length(t))
    Xt[1] = X0
    for i in 2:length(t)
        ?t = t[i] - t[i-1]
        dXt = r * Xt[i-1] * ?t + a * Xt[i-1] * (Bt[i] - Bt[i-1])
        Xt[i] = Xt[i-1] + dXt
    end
    
    return Xt
    
end"
"# test 
plot()
B = Brownian(.001,0.,1.,0.,1.)

t = range(B.Tmin,stop=B.Tmax,length=Int((B.Tmax - B.Tmin) / B.?))

for i in 1:10

    Bt = sample(B)

    Xt = black_scholes_trajectory(t, Bt, r=r, a=?, X0=X0)  # Simulate Black-Scholes trajectory
    plot!(t,Xt,label=""BSM trajectory $i"")
end
title!(""Trajectories of Black-Scholes equation r = $r, a = $?"")"
"# 5

struct Model
    drift::Function
    diffusion::Function
    diffusion_derivative::Function
end"
"function euler(model::Model, x0, t, Bt)
    ?t = t[2] -t[1]
    X = zeros(length(t))
    X[1] = x0
    for i in 2:length(t)
        X[i] = X[i-1] + model.drift(t, X[i-1]) * ?t + model.diffusion(t, X[i-1]) * (Bt[i] - Bt[i-1])
    end
    return X
end"
"function milstein(model::Model, x0, t, Bt)
    ?t = t[2] - t[1]
    X = zeros(length(t))
    X[1] = x0
    for i in 2:length(t)
        X[i] = X[i-1] + model.drift(t, X[i-1]) * ?t + model.diffusion(t, X[i-1]) * (Bt[i] - Bt[i-1]) +
               0.5 * model.diffusion(t, X[i-1]) * model.diffusion_derivative(t, X[i-1]) * ((Bt[i] - Bt[i-1])^2 - ?t)
    end
    return X
end"
"        drift_t = m.drift(t, Xt[i-1])
        diffusion_t = m.diffusion(t, Xt[i-1])
        dt_diffusion = m.d_diffusion(t, Xt[i-1])
        Xt_p=Xt[i-1]+drift_t*B.?+diffusion_t*sqrt(B.?)
        diffusion_p = m.diffusion(t, Xt_p)
        Xt[i] = Xt[i-1]+drift_t*B.?+diffusion_t*?Bt+(0.5/sqrt(B.?))*(diffusion_p - diffusion_t)*(?Bt^2-B.?)"
"function runge_kutta_1_5(model::Model, x0, t, Bt)
    ?t = t[2] - t[1]
    Xt = zeros(length(t))
    Xt[1] = x0
    for i in 2:length(t)
        drift_t = m.drift(t, Xt[i-1])
        diffusion_t = m.diffusion(t, Xt[i-1])
        dt_diffusion = m.diffusion_derivative(t, Xt[i-1])
        Xt_p = Xt[i-1] + drift_t * B.? + diffusion_t * sqrt(B.?)
        diffusion_p = m.diffusion(t, Xt_p)
        Xt[i] = Xt[i-1] + drift_t * B.? + diffusion_t * (Bt[i] - Bt[i-1]) +(0.5 / sqrt(B.?)) * 
                        (diffusion_p - diffusion_t) * ((Bt[i] - Bt[i-1])^2 - B.?)
    end
    return Xt
end"
"m = Model((t,x)->r*x,(t,x)->?*x,(t,x)->?)"
"function integrate(m::Model, t, Bt; X0=0.0,method=""Euler"")
    # Returns the trajectory of a stochastic differential equations
    # t:  sampling instant
    # Bt: input brownian motion trajectory
    # X0: initial value
    # method: 'Euler', 'Milstein' or 'Runge_Kutta_1.5'
    # output: trajectory X of the SDE
    ?t = t[2] - t[1]
    X = zeros(length(t))
    X[1] = X0


    if method == ""Euler""
        X = euler(m, X0, t, Bt)
    elseif method == ""Milstein""
        X = milstein(m, X0, t, Bt)
    elseif method == ""Runge_Kutta_1.5""
        X = runge_kutta_1_5(m, X0, t, Bt)
    else
        error(""Unsupported method. Choose 'Euler', 'Milstein', or 'Runge_Kutta_1.5'"")
    end


    return X
end"
"# Figures
B = Brownian(.001,0.,1.,0.,1.)
t = range(B.Tmin,stop=B.Tmax,length=Int((B.Tmax - B.Tmin) / B.?))
Bt = sample(B)
X_euler = integrate(m, t, Bt, X0=X0, method=""Euler"")
Xt = black_scholes_trajectory(t, Bt, r=r, a=?, X0=X0)
X_milstein = integrate(m, t, Bt, X0=X0, method=""Milstein"")
X_rk_1_5 = integrate(m, t, Bt, X0=X0, method=""Runge_Kutta_1.5"")"
"plot(size = (1300, 800))
plot!(t, X_euler, label = ""Euler trajectory"", xlabel = ""t"", ylabel=""Xt"", title=""Numerical Solutions"", linestyle=:dash)
plot!(t, Xt, label = ""BSM trajectory"")
plot!(t, X_milstein, label = ""Milestein trajectory"", xlabel = ""t"", linestyle=:dash)
plot!(t, X_rk_1_5, label = ""Runge-Kutta 1.5 Method"", linestyle=:dash)"
"plot()
plot!(t, Xt, label = ""BSM trajectory"")
plot!(t, X_euler, label = ""Euler trajectory"", xlabel = ""t"", ylabel=""Xt"", title=""Euler method"", linestyle=:dash)"
"plot()
plot!(t, Xt, label = ""BSM trajectory"", title = ""Milestein method"")
plot!(t, X_milstein, label = ""Milestein trajectory"", xlabel = ""t"", ylabel = ""Xt"",linestyle=:dash)"
"plot()
plot!(t, Xt, label = ""BSM trajectory"", xlabel=""t"", ylabel=""Xt"", title = ""Runge Kutta"")
plot!(t, X_rk_1_5, label = ""Runge-Kutta 1.5 Method"", linestyle=:dash)"
"using Statistics

# Calculate mean squared error
mse_euler = mean((X_euler - Xt).^2)
mse_milstein = mean((X_milstein - Xt).^2)
mse_rk_1_5 = mean((X_rk_1_5 - Xt).^2)

println(""Mean Squared Error (Euler): "", mse_euler)
println(""Mean Squared Error (Milstein): "", mse_milstein)
println(""Mean Squared Error (Runge-Kutta 1.5): "", mse_rk_1_5)"
"# 6 - trajectories of Cox-Ingersoll-Ross process
# note that in some cases numerical errors can lead
# to negative values
#------------------------------------------------
N = 100
? = 1e-2
T0 = 0
T = 1
a, b =5, 2
? = 0.6
?1, ?2 = 1, 3
X0 = 4"
"function CIR(X0)
    Xt = zeros(N)
    Xt[1] = X0
    Bt = Brownian(?, T0, T, 0.0, 1)
    B = sample(Bt)
    for i in 2:N
        if i <= Int( (N * ?) / T )
            Xt[i] = Xt[i-1] + (a - b * Xt[i-1]) * ? + ?1 * sqrt(Xt[i-1]) * (B[i] - B[i-1])
        else 
            Xt[i] = Xt[i-1] + (a - b * Xt[i-1]) * ? + ?2 * sqrt(Xt[i-1]) * (B[i] - B[i-1])
        end
    end
    return Xt
end

    "
"t = range(0,stop = 1, length = N)
plot()
Xt = CIR(X0)
plot(t,Xt, label = ""trajecory"", title = ""Cox-Ingersoll-Ross model"")"
"# 7 & 8 - Decision variable D_k
#--------------------------------------

function count_zi(trajectory, ind)
    Sk = 0
    if ind < length(trajectory)
        for i in 1:ind
            Sk += (((trajectory[i+1] - trajectory[i] - (a - b * trajectory[i]) * ?)) / sqrt( trajectory[i] * ? ) )^2
        end
    end
    return Sk
end
    

nb_traj = 30
trajectories = []
Dks = []
    
for i in 1:nb_traj
    Bt = Brownian(?, T0, T, 0.0, 1)
    B = sample(Bt)
    Dk = []
    
    trajectory = CIR(X0)
    push!(trajectories, trajectory)
    
    Sn = count_zi(trajectory, N-1)
    for k in 2:N-2
        Sk = count_zi(trajectory, k)
        push!(Dk, k * log(Sk/k) + (N - k) * log((Sn-Sk)/(N-k)))
    end
    push!(Dks,Dk)
end
    "
"plot()
for i in 1:10
    plot!(t, trajectories[i], label = ""trajectory $i"", title = ""CIR simulations (10/$nb_traj displayed)"")
end
plot!()"
"plot()
ks = 2:N-2
for i in 1:10
    plot!(ks, Dks[i], label = ""trajectory $i"", title = ""Evolution of Dk wrt k for mutiple simulations \n (10/$nb_traj displayed)"")
end
plot!()"
using Statistics
"# Calculate the argmin for each vector
argmin_indices = argmin.(Dks)

# Calculate the mean of the argmin indices
mean_? = mean(argmin_indices)

println(""? for each trajectroy "", argmin_indices/100)
println(""Estimate of ?: "", mean_?/100)"
"k = Int(round( (N * (mean_?/100) ) / T ) )
Sks = [count_zi(traj, k) for traj in trajectories] 
Sns = [count_zi(traj, N-1) for traj in trajectories] 

?1s = [sqrt(z/k) for z in Sks]
?2s = []
for i in 1:length(Sns)
    push!(?2s, sqrt( (Sns[i]-Sks[i])/(N-k) ))
end

?1 = mean(?1s)
?2 = mean(?2)

println(""?1 for each trajectroy "", ?1s)
println(""Estimate of ?1: "", ?1)

println(""?2 for each trajectroy "", ?2s)
println(""Estimate of ?2: "", ?2)"
"function kernel_density_estimation(X, h)
    kernel(x, xi) = exp(-(x - xi)^2 / (2 * h^2)) / (sqrt(2 * ?) * h)
    
    n = length(X)
    b_hat(x) = sum((xi - x) * kernel(x, xi) for xi in X) / (h * sum(kernel(x, xi) for xi in X))
    
    return b_hat
end"
"t = range(0,stop = 1, length = N)
plot()
Xt = CIR(X0)
plot(t,Xt, label = ""trajecory"", title = ""Cox-Ingersoll-Ross model"")"
"h = 1 / N^(1/5)
b_hat = kernel_density_estimation(Xt, h)"
"plot(xlabel = ""Xt"", title =""Estimation of b(Xt)"")
plot!(t, b_hat.(Xt), label= ""estimation of b(Xt)"")
plot!(t, a .- b.*Xt, label = ""actual b(Xt)"")    "
"mse_b = mean((b_hat.(Xt) - (a .- b.*Xt)).^2)
println(""Mean Squared Error (b): "", mse_b)"
"function CIR_b_hat(X0, b)
    Xt = zeros(N)
    Xt[1] = X0
    Bt = Brownian(?, T0, T, 0.0, 1)
    B = sample(Bt)
    for i in 2:N
        if i <= Int( (N * ?) / T )
            Xt[i] = Xt[i-1] + b(Xt[i-1]) * ? + ?1 * sqrt(Xt[i-1]) * (B[i] - B[i-1])
        else 
            Xt[i] = Xt[i-1] + b(Xt[i-1]) * ? + ?2 * sqrt(Xt[i-1]) * (B[i] - B[i-1])
        end
    end
    return Xt
end

    "
"nb_traj = 10
trajectories = []
Dks = []
    
for i in 1:nb_traj
    Bt = Brownian(?, T0, T, 0.0, 1)
    B = sample(Bt)
    Dk = []
    
    trajectory = CIR_b_hat(X0, b_hat)
    push!(trajectories, trajectory)
    
    Sn = count_zi(trajectory, N-1)
    for k in 2:N-2
        Sk = count_zi(trajectory, k)
        push!(Dk, k * log(Sk/k) + (N - k) * log((Sn-Sk)/(N-k)))
    end
    push!(Dks,Dk)
end
    "
"plot()
for i in 1:10
    plot!(t, trajectories[i], label = ""trajectory $i"", title = ""CIR simulations with estimation of b"")
end
plot!()"
"plot()
ks = 2:N-2
for i in 1:10
    plot!(ks, Dks[i], label = ""trajectory $i"", title = ""Evolution of Dk wrt k for mutiple simulations \n with estimation of b"")
end
plot!()"
"# Calculate the argmin for each vector
argmin_indices = argmin.(Dks)

# Calculate the mean of the argmin indices
mean_? = mean(argmin_indices)

println(""? for each trajectroy "", argmin_indices/100)
println(""Estimate of ?: "", mean_?/100)"
"k = Int(round( (N * (mean_?/100) ) / T ) )
Sks = [count_zi(traj, k) for traj in trajectories] 
Sns = [count_zi(traj, N-1) for traj in trajectories] 

?1s = [sqrt(z/k) for z in Sks]
?2s = []
for i in 1:length(Sns)
    push!(?2s, sqrt( (Sns[i]-Sks[i])/(N-k) ))
end

?1 = mean(?1s)
?2 = mean(?2)

println(""?1 for each trajectroy "", ?1s)
println(""Estimate of ?1: "", ?1)

println(""?2 for each trajectroy "", ?2s)
println(""Estimate of ?2: "", ?2)"
